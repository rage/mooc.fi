// Code generated by Prisma (prisma@1.33.0). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export type Maybe<T> = T | undefined | null;

export interface Exists {
  completion: (where?: CompletionWhereInput) => Promise<boolean>;
  completionRegistered: (
    where?: CompletionRegisteredWhereInput
  ) => Promise<boolean>;
  course: (where?: CourseWhereInput) => Promise<boolean>;
  openUniversityCourse: (
    where?: OpenUniversityCourseWhereInput
  ) => Promise<boolean>;
  user: (where?: UserWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  completion: (where: CompletionWhereUniqueInput) => CompletionNullablePromise;
  completions: (args?: {
    where?: CompletionWhereInput;
    orderBy?: CompletionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Completion>;
  completionsConnection: (args?: {
    where?: CompletionWhereInput;
    orderBy?: CompletionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => CompletionConnectionPromise;
  completionRegistered: (
    where: CompletionRegisteredWhereUniqueInput
  ) => CompletionRegisteredNullablePromise;
  completionRegistereds: (args?: {
    where?: CompletionRegisteredWhereInput;
    orderBy?: CompletionRegisteredOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<CompletionRegistered>;
  completionRegisteredsConnection: (args?: {
    where?: CompletionRegisteredWhereInput;
    orderBy?: CompletionRegisteredOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => CompletionRegisteredConnectionPromise;
  course: (where: CourseWhereUniqueInput) => CourseNullablePromise;
  courses: (args?: {
    where?: CourseWhereInput;
    orderBy?: CourseOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Course>;
  coursesConnection: (args?: {
    where?: CourseWhereInput;
    orderBy?: CourseOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => CourseConnectionPromise;
  openUniversityCourse: (
    where: OpenUniversityCourseWhereUniqueInput
  ) => OpenUniversityCourseNullablePromise;
  openUniversityCourses: (args?: {
    where?: OpenUniversityCourseWhereInput;
    orderBy?: OpenUniversityCourseOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<OpenUniversityCourse>;
  openUniversityCoursesConnection: (args?: {
    where?: OpenUniversityCourseWhereInput;
    orderBy?: OpenUniversityCourseOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => OpenUniversityCourseConnectionPromise;
  user: (where: UserWhereUniqueInput) => UserNullablePromise;
  users: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<User>;
  usersConnection: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => UserConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createCompletion: (data: CompletionCreateInput) => CompletionPromise;
  updateCompletion: (args: {
    data: CompletionUpdateInput;
    where: CompletionWhereUniqueInput;
  }) => CompletionPromise;
  updateManyCompletions: (args: {
    data: CompletionUpdateManyMutationInput;
    where?: CompletionWhereInput;
  }) => BatchPayloadPromise;
  upsertCompletion: (args: {
    where: CompletionWhereUniqueInput;
    create: CompletionCreateInput;
    update: CompletionUpdateInput;
  }) => CompletionPromise;
  deleteCompletion: (where: CompletionWhereUniqueInput) => CompletionPromise;
  deleteManyCompletions: (where?: CompletionWhereInput) => BatchPayloadPromise;
  createCompletionRegistered: (
    data: CompletionRegisteredCreateInput
  ) => CompletionRegisteredPromise;
  updateCompletionRegistered: (args: {
    data: CompletionRegisteredUpdateInput;
    where: CompletionRegisteredWhereUniqueInput;
  }) => CompletionRegisteredPromise;
  updateManyCompletionRegistereds: (args: {
    data: CompletionRegisteredUpdateManyMutationInput;
    where?: CompletionRegisteredWhereInput;
  }) => BatchPayloadPromise;
  upsertCompletionRegistered: (args: {
    where: CompletionRegisteredWhereUniqueInput;
    create: CompletionRegisteredCreateInput;
    update: CompletionRegisteredUpdateInput;
  }) => CompletionRegisteredPromise;
  deleteCompletionRegistered: (
    where: CompletionRegisteredWhereUniqueInput
  ) => CompletionRegisteredPromise;
  deleteManyCompletionRegistereds: (
    where?: CompletionRegisteredWhereInput
  ) => BatchPayloadPromise;
  createCourse: (data: CourseCreateInput) => CoursePromise;
  updateCourse: (args: {
    data: CourseUpdateInput;
    where: CourseWhereUniqueInput;
  }) => CoursePromise;
  updateManyCourses: (args: {
    data: CourseUpdateManyMutationInput;
    where?: CourseWhereInput;
  }) => BatchPayloadPromise;
  upsertCourse: (args: {
    where: CourseWhereUniqueInput;
    create: CourseCreateInput;
    update: CourseUpdateInput;
  }) => CoursePromise;
  deleteCourse: (where: CourseWhereUniqueInput) => CoursePromise;
  deleteManyCourses: (where?: CourseWhereInput) => BatchPayloadPromise;
  createOpenUniversityCourse: (
    data: OpenUniversityCourseCreateInput
  ) => OpenUniversityCoursePromise;
  updateOpenUniversityCourse: (args: {
    data: OpenUniversityCourseUpdateInput;
    where: OpenUniversityCourseWhereUniqueInput;
  }) => OpenUniversityCoursePromise;
  updateManyOpenUniversityCourses: (args: {
    data: OpenUniversityCourseUpdateManyMutationInput;
    where?: OpenUniversityCourseWhereInput;
  }) => BatchPayloadPromise;
  upsertOpenUniversityCourse: (args: {
    where: OpenUniversityCourseWhereUniqueInput;
    create: OpenUniversityCourseCreateInput;
    update: OpenUniversityCourseUpdateInput;
  }) => OpenUniversityCoursePromise;
  deleteOpenUniversityCourse: (
    where: OpenUniversityCourseWhereUniqueInput
  ) => OpenUniversityCoursePromise;
  deleteManyOpenUniversityCourses: (
    where?: OpenUniversityCourseWhereInput
  ) => BatchPayloadPromise;
  createUser: (data: UserCreateInput) => UserPromise;
  updateUser: (args: {
    data: UserUpdateInput;
    where: UserWhereUniqueInput;
  }) => UserPromise;
  updateManyUsers: (args: {
    data: UserUpdateManyMutationInput;
    where?: UserWhereInput;
  }) => BatchPayloadPromise;
  upsertUser: (args: {
    where: UserWhereUniqueInput;
    create: UserCreateInput;
    update: UserUpdateInput;
  }) => UserPromise;
  deleteUser: (where: UserWhereUniqueInput) => UserPromise;
  deleteManyUsers: (where?: UserWhereInput) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  completion: (
    where?: CompletionSubscriptionWhereInput
  ) => CompletionSubscriptionPayloadSubscription;
  completionRegistered: (
    where?: CompletionRegisteredSubscriptionWhereInput
  ) => CompletionRegisteredSubscriptionPayloadSubscription;
  course: (
    where?: CourseSubscriptionWhereInput
  ) => CourseSubscriptionPayloadSubscription;
  openUniversityCourse: (
    where?: OpenUniversityCourseSubscriptionWhereInput
  ) => OpenUniversityCourseSubscriptionPayloadSubscription;
  user: (
    where?: UserSubscriptionWhereInput
  ) => UserSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type CompletionOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "created_at_ASC"
  | "created_at_DESC"
  | "updated_at_ASC"
  | "updated_at_DESC"
  | "user_upstream_id_ASC"
  | "user_upstream_id_DESC"
  | "email_ASC"
  | "email_DESC"
  | "student_number_ASC"
  | "student_number_DESC"
  | "completion_language_ASC"
  | "completion_language_DESC";

export type CompletionRegisteredOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "created_at_ASC"
  | "created_at_DESC"
  | "updated_at_ASC"
  | "updated_at_DESC"
  | "real_student_number_ASC"
  | "real_student_number_DESC"
  | "organisation_ASC"
  | "organisation_DESC";

export type OpenUniversityCourseOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "created_at_ASC"
  | "created_at_DESC"
  | "updated_at_ASC"
  | "updated_at_DESC"
  | "course_code_ASC"
  | "course_code_DESC";

export type CourseOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "created_at_ASC"
  | "created_at_DESC"
  | "updated_at_ASC"
  | "updated_at_DESC"
  | "name_ASC"
  | "name_DESC"
  | "slug_ASC"
  | "slug_DESC";

export type UserOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "upstream_id_ASC"
  | "upstream_id_DESC"
  | "created_at_ASC"
  | "created_at_DESC"
  | "updated_at_ASC"
  | "updated_at_DESC"
  | "first_name_ASC"
  | "first_name_DESC"
  | "last_name_ASC"
  | "last_name_DESC"
  | "username_ASC"
  | "username_DESC"
  | "email_ASC"
  | "email_DESC"
  | "administrator_ASC"
  | "administrator_DESC"
  | "student_number_ASC"
  | "student_number_DESC"
  | "real_student_number_ASC"
  | "real_student_number_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export type CompletionWhereUniqueInput = AtLeastOne<{
  id: Maybe<UUID>;
}>;

export interface CompletionWhereInput {
  id?: Maybe<UUID>;
  id_not?: Maybe<UUID>;
  id_in?: Maybe<UUID[] | UUID>;
  id_not_in?: Maybe<UUID[] | UUID>;
  id_lt?: Maybe<UUID>;
  id_lte?: Maybe<UUID>;
  id_gt?: Maybe<UUID>;
  id_gte?: Maybe<UUID>;
  id_contains?: Maybe<UUID>;
  id_not_contains?: Maybe<UUID>;
  id_starts_with?: Maybe<UUID>;
  id_not_starts_with?: Maybe<UUID>;
  id_ends_with?: Maybe<UUID>;
  id_not_ends_with?: Maybe<UUID>;
  created_at?: Maybe<DateTimeInput>;
  created_at_not?: Maybe<DateTimeInput>;
  created_at_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  created_at_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  created_at_lt?: Maybe<DateTimeInput>;
  created_at_lte?: Maybe<DateTimeInput>;
  created_at_gt?: Maybe<DateTimeInput>;
  created_at_gte?: Maybe<DateTimeInput>;
  updated_at?: Maybe<DateTimeInput>;
  updated_at_not?: Maybe<DateTimeInput>;
  updated_at_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updated_at_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updated_at_lt?: Maybe<DateTimeInput>;
  updated_at_lte?: Maybe<DateTimeInput>;
  updated_at_gt?: Maybe<DateTimeInput>;
  updated_at_gte?: Maybe<DateTimeInput>;
  user_upstream_id?: Maybe<Int>;
  user_upstream_id_not?: Maybe<Int>;
  user_upstream_id_in?: Maybe<Int[] | Int>;
  user_upstream_id_not_in?: Maybe<Int[] | Int>;
  user_upstream_id_lt?: Maybe<Int>;
  user_upstream_id_lte?: Maybe<Int>;
  user_upstream_id_gt?: Maybe<Int>;
  user_upstream_id_gte?: Maybe<Int>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  student_number?: Maybe<String>;
  student_number_not?: Maybe<String>;
  student_number_in?: Maybe<String[] | String>;
  student_number_not_in?: Maybe<String[] | String>;
  student_number_lt?: Maybe<String>;
  student_number_lte?: Maybe<String>;
  student_number_gt?: Maybe<String>;
  student_number_gte?: Maybe<String>;
  student_number_contains?: Maybe<String>;
  student_number_not_contains?: Maybe<String>;
  student_number_starts_with?: Maybe<String>;
  student_number_not_starts_with?: Maybe<String>;
  student_number_ends_with?: Maybe<String>;
  student_number_not_ends_with?: Maybe<String>;
  user?: Maybe<UserWhereInput>;
  course?: Maybe<CourseWhereInput>;
  completion_language?: Maybe<String>;
  completion_language_not?: Maybe<String>;
  completion_language_in?: Maybe<String[] | String>;
  completion_language_not_in?: Maybe<String[] | String>;
  completion_language_lt?: Maybe<String>;
  completion_language_lte?: Maybe<String>;
  completion_language_gt?: Maybe<String>;
  completion_language_gte?: Maybe<String>;
  completion_language_contains?: Maybe<String>;
  completion_language_not_contains?: Maybe<String>;
  completion_language_starts_with?: Maybe<String>;
  completion_language_not_starts_with?: Maybe<String>;
  completion_language_ends_with?: Maybe<String>;
  completion_language_not_ends_with?: Maybe<String>;
  AND?: Maybe<CompletionWhereInput[] | CompletionWhereInput>;
  OR?: Maybe<CompletionWhereInput[] | CompletionWhereInput>;
  NOT?: Maybe<CompletionWhereInput[] | CompletionWhereInput>;
}

export interface UserWhereInput {
  id?: Maybe<UUID>;
  id_not?: Maybe<UUID>;
  id_in?: Maybe<UUID[] | UUID>;
  id_not_in?: Maybe<UUID[] | UUID>;
  id_lt?: Maybe<UUID>;
  id_lte?: Maybe<UUID>;
  id_gt?: Maybe<UUID>;
  id_gte?: Maybe<UUID>;
  id_contains?: Maybe<UUID>;
  id_not_contains?: Maybe<UUID>;
  id_starts_with?: Maybe<UUID>;
  id_not_starts_with?: Maybe<UUID>;
  id_ends_with?: Maybe<UUID>;
  id_not_ends_with?: Maybe<UUID>;
  upstream_id?: Maybe<Int>;
  upstream_id_not?: Maybe<Int>;
  upstream_id_in?: Maybe<Int[] | Int>;
  upstream_id_not_in?: Maybe<Int[] | Int>;
  upstream_id_lt?: Maybe<Int>;
  upstream_id_lte?: Maybe<Int>;
  upstream_id_gt?: Maybe<Int>;
  upstream_id_gte?: Maybe<Int>;
  created_at?: Maybe<DateTimeInput>;
  created_at_not?: Maybe<DateTimeInput>;
  created_at_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  created_at_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  created_at_lt?: Maybe<DateTimeInput>;
  created_at_lte?: Maybe<DateTimeInput>;
  created_at_gt?: Maybe<DateTimeInput>;
  created_at_gte?: Maybe<DateTimeInput>;
  updated_at?: Maybe<DateTimeInput>;
  updated_at_not?: Maybe<DateTimeInput>;
  updated_at_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updated_at_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updated_at_lt?: Maybe<DateTimeInput>;
  updated_at_lte?: Maybe<DateTimeInput>;
  updated_at_gt?: Maybe<DateTimeInput>;
  updated_at_gte?: Maybe<DateTimeInput>;
  first_name?: Maybe<String>;
  first_name_not?: Maybe<String>;
  first_name_in?: Maybe<String[] | String>;
  first_name_not_in?: Maybe<String[] | String>;
  first_name_lt?: Maybe<String>;
  first_name_lte?: Maybe<String>;
  first_name_gt?: Maybe<String>;
  first_name_gte?: Maybe<String>;
  first_name_contains?: Maybe<String>;
  first_name_not_contains?: Maybe<String>;
  first_name_starts_with?: Maybe<String>;
  first_name_not_starts_with?: Maybe<String>;
  first_name_ends_with?: Maybe<String>;
  first_name_not_ends_with?: Maybe<String>;
  last_name?: Maybe<String>;
  last_name_not?: Maybe<String>;
  last_name_in?: Maybe<String[] | String>;
  last_name_not_in?: Maybe<String[] | String>;
  last_name_lt?: Maybe<String>;
  last_name_lte?: Maybe<String>;
  last_name_gt?: Maybe<String>;
  last_name_gte?: Maybe<String>;
  last_name_contains?: Maybe<String>;
  last_name_not_contains?: Maybe<String>;
  last_name_starts_with?: Maybe<String>;
  last_name_not_starts_with?: Maybe<String>;
  last_name_ends_with?: Maybe<String>;
  last_name_not_ends_with?: Maybe<String>;
  username?: Maybe<String>;
  username_not?: Maybe<String>;
  username_in?: Maybe<String[] | String>;
  username_not_in?: Maybe<String[] | String>;
  username_lt?: Maybe<String>;
  username_lte?: Maybe<String>;
  username_gt?: Maybe<String>;
  username_gte?: Maybe<String>;
  username_contains?: Maybe<String>;
  username_not_contains?: Maybe<String>;
  username_starts_with?: Maybe<String>;
  username_not_starts_with?: Maybe<String>;
  username_ends_with?: Maybe<String>;
  username_not_ends_with?: Maybe<String>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  administrator?: Maybe<Boolean>;
  administrator_not?: Maybe<Boolean>;
  student_number?: Maybe<String>;
  student_number_not?: Maybe<String>;
  student_number_in?: Maybe<String[] | String>;
  student_number_not_in?: Maybe<String[] | String>;
  student_number_lt?: Maybe<String>;
  student_number_lte?: Maybe<String>;
  student_number_gt?: Maybe<String>;
  student_number_gte?: Maybe<String>;
  student_number_contains?: Maybe<String>;
  student_number_not_contains?: Maybe<String>;
  student_number_starts_with?: Maybe<String>;
  student_number_not_starts_with?: Maybe<String>;
  student_number_ends_with?: Maybe<String>;
  student_number_not_ends_with?: Maybe<String>;
  real_student_number?: Maybe<String>;
  real_student_number_not?: Maybe<String>;
  real_student_number_in?: Maybe<String[] | String>;
  real_student_number_not_in?: Maybe<String[] | String>;
  real_student_number_lt?: Maybe<String>;
  real_student_number_lte?: Maybe<String>;
  real_student_number_gt?: Maybe<String>;
  real_student_number_gte?: Maybe<String>;
  real_student_number_contains?: Maybe<String>;
  real_student_number_not_contains?: Maybe<String>;
  real_student_number_starts_with?: Maybe<String>;
  real_student_number_not_starts_with?: Maybe<String>;
  real_student_number_ends_with?: Maybe<String>;
  real_student_number_not_ends_with?: Maybe<String>;
  completions_every?: Maybe<CompletionWhereInput>;
  completions_some?: Maybe<CompletionWhereInput>;
  completions_none?: Maybe<CompletionWhereInput>;
  registered_completions_every?: Maybe<CompletionRegisteredWhereInput>;
  registered_completions_some?: Maybe<CompletionRegisteredWhereInput>;
  registered_completions_none?: Maybe<CompletionRegisteredWhereInput>;
  AND?: Maybe<UserWhereInput[] | UserWhereInput>;
  OR?: Maybe<UserWhereInput[] | UserWhereInput>;
  NOT?: Maybe<UserWhereInput[] | UserWhereInput>;
}

export interface CompletionRegisteredWhereInput {
  id?: Maybe<UUID>;
  id_not?: Maybe<UUID>;
  id_in?: Maybe<UUID[] | UUID>;
  id_not_in?: Maybe<UUID[] | UUID>;
  id_lt?: Maybe<UUID>;
  id_lte?: Maybe<UUID>;
  id_gt?: Maybe<UUID>;
  id_gte?: Maybe<UUID>;
  id_contains?: Maybe<UUID>;
  id_not_contains?: Maybe<UUID>;
  id_starts_with?: Maybe<UUID>;
  id_not_starts_with?: Maybe<UUID>;
  id_ends_with?: Maybe<UUID>;
  id_not_ends_with?: Maybe<UUID>;
  created_at?: Maybe<DateTimeInput>;
  created_at_not?: Maybe<DateTimeInput>;
  created_at_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  created_at_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  created_at_lt?: Maybe<DateTimeInput>;
  created_at_lte?: Maybe<DateTimeInput>;
  created_at_gt?: Maybe<DateTimeInput>;
  created_at_gte?: Maybe<DateTimeInput>;
  updated_at?: Maybe<DateTimeInput>;
  updated_at_not?: Maybe<DateTimeInput>;
  updated_at_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updated_at_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updated_at_lt?: Maybe<DateTimeInput>;
  updated_at_lte?: Maybe<DateTimeInput>;
  updated_at_gt?: Maybe<DateTimeInput>;
  updated_at_gte?: Maybe<DateTimeInput>;
  user?: Maybe<UserWhereInput>;
  course?: Maybe<CourseWhereInput>;
  real_student_number?: Maybe<String>;
  real_student_number_not?: Maybe<String>;
  real_student_number_in?: Maybe<String[] | String>;
  real_student_number_not_in?: Maybe<String[] | String>;
  real_student_number_lt?: Maybe<String>;
  real_student_number_lte?: Maybe<String>;
  real_student_number_gt?: Maybe<String>;
  real_student_number_gte?: Maybe<String>;
  real_student_number_contains?: Maybe<String>;
  real_student_number_not_contains?: Maybe<String>;
  real_student_number_starts_with?: Maybe<String>;
  real_student_number_not_starts_with?: Maybe<String>;
  real_student_number_ends_with?: Maybe<String>;
  real_student_number_not_ends_with?: Maybe<String>;
  organisation?: Maybe<String>;
  organisation_not?: Maybe<String>;
  organisation_in?: Maybe<String[] | String>;
  organisation_not_in?: Maybe<String[] | String>;
  organisation_lt?: Maybe<String>;
  organisation_lte?: Maybe<String>;
  organisation_gt?: Maybe<String>;
  organisation_gte?: Maybe<String>;
  organisation_contains?: Maybe<String>;
  organisation_not_contains?: Maybe<String>;
  organisation_starts_with?: Maybe<String>;
  organisation_not_starts_with?: Maybe<String>;
  organisation_ends_with?: Maybe<String>;
  organisation_not_ends_with?: Maybe<String>;
  completion?: Maybe<CompletionWhereInput>;
  AND?: Maybe<
    CompletionRegisteredWhereInput[] | CompletionRegisteredWhereInput
  >;
  OR?: Maybe<CompletionRegisteredWhereInput[] | CompletionRegisteredWhereInput>;
  NOT?: Maybe<
    CompletionRegisteredWhereInput[] | CompletionRegisteredWhereInput
  >;
}

export interface CourseWhereInput {
  id?: Maybe<UUID>;
  id_not?: Maybe<UUID>;
  id_in?: Maybe<UUID[] | UUID>;
  id_not_in?: Maybe<UUID[] | UUID>;
  id_lt?: Maybe<UUID>;
  id_lte?: Maybe<UUID>;
  id_gt?: Maybe<UUID>;
  id_gte?: Maybe<UUID>;
  id_contains?: Maybe<UUID>;
  id_not_contains?: Maybe<UUID>;
  id_starts_with?: Maybe<UUID>;
  id_not_starts_with?: Maybe<UUID>;
  id_ends_with?: Maybe<UUID>;
  id_not_ends_with?: Maybe<UUID>;
  created_at?: Maybe<DateTimeInput>;
  created_at_not?: Maybe<DateTimeInput>;
  created_at_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  created_at_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  created_at_lt?: Maybe<DateTimeInput>;
  created_at_lte?: Maybe<DateTimeInput>;
  created_at_gt?: Maybe<DateTimeInput>;
  created_at_gte?: Maybe<DateTimeInput>;
  updated_at?: Maybe<DateTimeInput>;
  updated_at_not?: Maybe<DateTimeInput>;
  updated_at_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updated_at_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updated_at_lt?: Maybe<DateTimeInput>;
  updated_at_lte?: Maybe<DateTimeInput>;
  updated_at_gt?: Maybe<DateTimeInput>;
  updated_at_gte?: Maybe<DateTimeInput>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  slug?: Maybe<String>;
  slug_not?: Maybe<String>;
  slug_in?: Maybe<String[] | String>;
  slug_not_in?: Maybe<String[] | String>;
  slug_lt?: Maybe<String>;
  slug_lte?: Maybe<String>;
  slug_gt?: Maybe<String>;
  slug_gte?: Maybe<String>;
  slug_contains?: Maybe<String>;
  slug_not_contains?: Maybe<String>;
  slug_starts_with?: Maybe<String>;
  slug_not_starts_with?: Maybe<String>;
  slug_ends_with?: Maybe<String>;
  slug_not_ends_with?: Maybe<String>;
  open_university_courses_every?: Maybe<OpenUniversityCourseWhereInput>;
  open_university_courses_some?: Maybe<OpenUniversityCourseWhereInput>;
  open_university_courses_none?: Maybe<OpenUniversityCourseWhereInput>;
  AND?: Maybe<CourseWhereInput[] | CourseWhereInput>;
  OR?: Maybe<CourseWhereInput[] | CourseWhereInput>;
  NOT?: Maybe<CourseWhereInput[] | CourseWhereInput>;
}

export interface OpenUniversityCourseWhereInput {
  id?: Maybe<UUID>;
  id_not?: Maybe<UUID>;
  id_in?: Maybe<UUID[] | UUID>;
  id_not_in?: Maybe<UUID[] | UUID>;
  id_lt?: Maybe<UUID>;
  id_lte?: Maybe<UUID>;
  id_gt?: Maybe<UUID>;
  id_gte?: Maybe<UUID>;
  id_contains?: Maybe<UUID>;
  id_not_contains?: Maybe<UUID>;
  id_starts_with?: Maybe<UUID>;
  id_not_starts_with?: Maybe<UUID>;
  id_ends_with?: Maybe<UUID>;
  id_not_ends_with?: Maybe<UUID>;
  created_at?: Maybe<DateTimeInput>;
  created_at_not?: Maybe<DateTimeInput>;
  created_at_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  created_at_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  created_at_lt?: Maybe<DateTimeInput>;
  created_at_lte?: Maybe<DateTimeInput>;
  created_at_gt?: Maybe<DateTimeInput>;
  created_at_gte?: Maybe<DateTimeInput>;
  updated_at?: Maybe<DateTimeInput>;
  updated_at_not?: Maybe<DateTimeInput>;
  updated_at_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updated_at_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updated_at_lt?: Maybe<DateTimeInput>;
  updated_at_lte?: Maybe<DateTimeInput>;
  updated_at_gt?: Maybe<DateTimeInput>;
  updated_at_gte?: Maybe<DateTimeInput>;
  course_code?: Maybe<String>;
  course_code_not?: Maybe<String>;
  course_code_in?: Maybe<String[] | String>;
  course_code_not_in?: Maybe<String[] | String>;
  course_code_lt?: Maybe<String>;
  course_code_lte?: Maybe<String>;
  course_code_gt?: Maybe<String>;
  course_code_gte?: Maybe<String>;
  course_code_contains?: Maybe<String>;
  course_code_not_contains?: Maybe<String>;
  course_code_starts_with?: Maybe<String>;
  course_code_not_starts_with?: Maybe<String>;
  course_code_ends_with?: Maybe<String>;
  course_code_not_ends_with?: Maybe<String>;
  course?: Maybe<CourseWhereInput>;
  AND?: Maybe<
    OpenUniversityCourseWhereInput[] | OpenUniversityCourseWhereInput
  >;
  OR?: Maybe<OpenUniversityCourseWhereInput[] | OpenUniversityCourseWhereInput>;
  NOT?: Maybe<
    OpenUniversityCourseWhereInput[] | OpenUniversityCourseWhereInput
  >;
}

export type CompletionRegisteredWhereUniqueInput = AtLeastOne<{
  id: Maybe<UUID>;
}>;

export type CourseWhereUniqueInput = AtLeastOne<{
  id: Maybe<UUID>;
  slug?: Maybe<String>;
}>;

export type OpenUniversityCourseWhereUniqueInput = AtLeastOne<{
  id: Maybe<UUID>;
  course_code?: Maybe<String>;
}>;

export type UserWhereUniqueInput = AtLeastOne<{
  id: Maybe<UUID>;
  upstream_id?: Maybe<Int>;
  username?: Maybe<String>;
}>;

export interface CompletionCreateInput {
  id?: Maybe<UUID>;
  user_upstream_id?: Maybe<Int>;
  email: String;
  student_number?: Maybe<String>;
  user: UserCreateOneWithoutCompletionsInput;
  course: CourseCreateOneInput;
  completion_language?: Maybe<String>;
}

export interface UserCreateOneWithoutCompletionsInput {
  create?: Maybe<UserCreateWithoutCompletionsInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserCreateWithoutCompletionsInput {
  id?: Maybe<UUID>;
  upstream_id: Int;
  first_name?: Maybe<String>;
  last_name?: Maybe<String>;
  username: String;
  email: String;
  administrator: Boolean;
  student_number?: Maybe<String>;
  real_student_number?: Maybe<String>;
  registered_completions?: Maybe<
    CompletionRegisteredCreateManyWithoutUserInput
  >;
}

export interface CompletionRegisteredCreateManyWithoutUserInput {
  create?: Maybe<
    | CompletionRegisteredCreateWithoutUserInput[]
    | CompletionRegisteredCreateWithoutUserInput
  >;
  connect?: Maybe<
    | CompletionRegisteredWhereUniqueInput[]
    | CompletionRegisteredWhereUniqueInput
  >;
}

export interface CompletionRegisteredCreateWithoutUserInput {
  id?: Maybe<UUID>;
  course: CourseCreateOneInput;
  real_student_number: String;
  organisation: String;
  completion: CompletionCreateOneInput;
}

export interface CourseCreateOneInput {
  create?: Maybe<CourseCreateInput>;
  connect?: Maybe<CourseWhereUniqueInput>;
}

export interface CourseCreateInput {
  id?: Maybe<UUID>;
  name: String;
  slug: String;
  open_university_courses?: Maybe<
    OpenUniversityCourseCreateManyWithoutCourseInput
  >;
}

export interface OpenUniversityCourseCreateManyWithoutCourseInput {
  create?: Maybe<
    | OpenUniversityCourseCreateWithoutCourseInput[]
    | OpenUniversityCourseCreateWithoutCourseInput
  >;
  connect?: Maybe<
    | OpenUniversityCourseWhereUniqueInput[]
    | OpenUniversityCourseWhereUniqueInput
  >;
}

export interface OpenUniversityCourseCreateWithoutCourseInput {
  id?: Maybe<UUID>;
  course_code: String;
}

export interface CompletionCreateOneInput {
  create?: Maybe<CompletionCreateInput>;
  connect?: Maybe<CompletionWhereUniqueInput>;
}

export interface CompletionUpdateInput {
  user_upstream_id?: Maybe<Int>;
  email?: Maybe<String>;
  student_number?: Maybe<String>;
  user?: Maybe<UserUpdateOneRequiredWithoutCompletionsInput>;
  course?: Maybe<CourseUpdateOneRequiredInput>;
  completion_language?: Maybe<String>;
}

export interface UserUpdateOneRequiredWithoutCompletionsInput {
  create?: Maybe<UserCreateWithoutCompletionsInput>;
  update?: Maybe<UserUpdateWithoutCompletionsDataInput>;
  upsert?: Maybe<UserUpsertWithoutCompletionsInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserUpdateWithoutCompletionsDataInput {
  upstream_id?: Maybe<Int>;
  first_name?: Maybe<String>;
  last_name?: Maybe<String>;
  username?: Maybe<String>;
  email?: Maybe<String>;
  administrator?: Maybe<Boolean>;
  student_number?: Maybe<String>;
  real_student_number?: Maybe<String>;
  registered_completions?: Maybe<
    CompletionRegisteredUpdateManyWithoutUserInput
  >;
}

export interface CompletionRegisteredUpdateManyWithoutUserInput {
  create?: Maybe<
    | CompletionRegisteredCreateWithoutUserInput[]
    | CompletionRegisteredCreateWithoutUserInput
  >;
  delete?: Maybe<
    | CompletionRegisteredWhereUniqueInput[]
    | CompletionRegisteredWhereUniqueInput
  >;
  connect?: Maybe<
    | CompletionRegisteredWhereUniqueInput[]
    | CompletionRegisteredWhereUniqueInput
  >;
  set?: Maybe<
    | CompletionRegisteredWhereUniqueInput[]
    | CompletionRegisteredWhereUniqueInput
  >;
  disconnect?: Maybe<
    | CompletionRegisteredWhereUniqueInput[]
    | CompletionRegisteredWhereUniqueInput
  >;
  update?: Maybe<
    | CompletionRegisteredUpdateWithWhereUniqueWithoutUserInput[]
    | CompletionRegisteredUpdateWithWhereUniqueWithoutUserInput
  >;
  upsert?: Maybe<
    | CompletionRegisteredUpsertWithWhereUniqueWithoutUserInput[]
    | CompletionRegisteredUpsertWithWhereUniqueWithoutUserInput
  >;
  deleteMany?: Maybe<
    | CompletionRegisteredScalarWhereInput[]
    | CompletionRegisteredScalarWhereInput
  >;
  updateMany?: Maybe<
    | CompletionRegisteredUpdateManyWithWhereNestedInput[]
    | CompletionRegisteredUpdateManyWithWhereNestedInput
  >;
}

export interface CompletionRegisteredUpdateWithWhereUniqueWithoutUserInput {
  where: CompletionRegisteredWhereUniqueInput;
  data: CompletionRegisteredUpdateWithoutUserDataInput;
}

export interface CompletionRegisteredUpdateWithoutUserDataInput {
  course?: Maybe<CourseUpdateOneRequiredInput>;
  real_student_number?: Maybe<String>;
  organisation?: Maybe<String>;
  completion?: Maybe<CompletionUpdateOneRequiredInput>;
}

export interface CourseUpdateOneRequiredInput {
  create?: Maybe<CourseCreateInput>;
  update?: Maybe<CourseUpdateDataInput>;
  upsert?: Maybe<CourseUpsertNestedInput>;
  connect?: Maybe<CourseWhereUniqueInput>;
}

export interface CourseUpdateDataInput {
  name?: Maybe<String>;
  slug?: Maybe<String>;
  open_university_courses?: Maybe<
    OpenUniversityCourseUpdateManyWithoutCourseInput
  >;
}

export interface OpenUniversityCourseUpdateManyWithoutCourseInput {
  create?: Maybe<
    | OpenUniversityCourseCreateWithoutCourseInput[]
    | OpenUniversityCourseCreateWithoutCourseInput
  >;
  delete?: Maybe<
    | OpenUniversityCourseWhereUniqueInput[]
    | OpenUniversityCourseWhereUniqueInput
  >;
  connect?: Maybe<
    | OpenUniversityCourseWhereUniqueInput[]
    | OpenUniversityCourseWhereUniqueInput
  >;
  set?: Maybe<
    | OpenUniversityCourseWhereUniqueInput[]
    | OpenUniversityCourseWhereUniqueInput
  >;
  disconnect?: Maybe<
    | OpenUniversityCourseWhereUniqueInput[]
    | OpenUniversityCourseWhereUniqueInput
  >;
  update?: Maybe<
    | OpenUniversityCourseUpdateWithWhereUniqueWithoutCourseInput[]
    | OpenUniversityCourseUpdateWithWhereUniqueWithoutCourseInput
  >;
  upsert?: Maybe<
    | OpenUniversityCourseUpsertWithWhereUniqueWithoutCourseInput[]
    | OpenUniversityCourseUpsertWithWhereUniqueWithoutCourseInput
  >;
  deleteMany?: Maybe<
    | OpenUniversityCourseScalarWhereInput[]
    | OpenUniversityCourseScalarWhereInput
  >;
  updateMany?: Maybe<
    | OpenUniversityCourseUpdateManyWithWhereNestedInput[]
    | OpenUniversityCourseUpdateManyWithWhereNestedInput
  >;
}

export interface OpenUniversityCourseUpdateWithWhereUniqueWithoutCourseInput {
  where: OpenUniversityCourseWhereUniqueInput;
  data: OpenUniversityCourseUpdateWithoutCourseDataInput;
}

export interface OpenUniversityCourseUpdateWithoutCourseDataInput {
  course_code?: Maybe<String>;
}

export interface OpenUniversityCourseUpsertWithWhereUniqueWithoutCourseInput {
  where: OpenUniversityCourseWhereUniqueInput;
  update: OpenUniversityCourseUpdateWithoutCourseDataInput;
  create: OpenUniversityCourseCreateWithoutCourseInput;
}

export interface OpenUniversityCourseScalarWhereInput {
  id?: Maybe<UUID>;
  id_not?: Maybe<UUID>;
  id_in?: Maybe<UUID[] | UUID>;
  id_not_in?: Maybe<UUID[] | UUID>;
  id_lt?: Maybe<UUID>;
  id_lte?: Maybe<UUID>;
  id_gt?: Maybe<UUID>;
  id_gte?: Maybe<UUID>;
  id_contains?: Maybe<UUID>;
  id_not_contains?: Maybe<UUID>;
  id_starts_with?: Maybe<UUID>;
  id_not_starts_with?: Maybe<UUID>;
  id_ends_with?: Maybe<UUID>;
  id_not_ends_with?: Maybe<UUID>;
  created_at?: Maybe<DateTimeInput>;
  created_at_not?: Maybe<DateTimeInput>;
  created_at_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  created_at_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  created_at_lt?: Maybe<DateTimeInput>;
  created_at_lte?: Maybe<DateTimeInput>;
  created_at_gt?: Maybe<DateTimeInput>;
  created_at_gte?: Maybe<DateTimeInput>;
  updated_at?: Maybe<DateTimeInput>;
  updated_at_not?: Maybe<DateTimeInput>;
  updated_at_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updated_at_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updated_at_lt?: Maybe<DateTimeInput>;
  updated_at_lte?: Maybe<DateTimeInput>;
  updated_at_gt?: Maybe<DateTimeInput>;
  updated_at_gte?: Maybe<DateTimeInput>;
  course_code?: Maybe<String>;
  course_code_not?: Maybe<String>;
  course_code_in?: Maybe<String[] | String>;
  course_code_not_in?: Maybe<String[] | String>;
  course_code_lt?: Maybe<String>;
  course_code_lte?: Maybe<String>;
  course_code_gt?: Maybe<String>;
  course_code_gte?: Maybe<String>;
  course_code_contains?: Maybe<String>;
  course_code_not_contains?: Maybe<String>;
  course_code_starts_with?: Maybe<String>;
  course_code_not_starts_with?: Maybe<String>;
  course_code_ends_with?: Maybe<String>;
  course_code_not_ends_with?: Maybe<String>;
  AND?: Maybe<
    | OpenUniversityCourseScalarWhereInput[]
    | OpenUniversityCourseScalarWhereInput
  >;
  OR?: Maybe<
    | OpenUniversityCourseScalarWhereInput[]
    | OpenUniversityCourseScalarWhereInput
  >;
  NOT?: Maybe<
    | OpenUniversityCourseScalarWhereInput[]
    | OpenUniversityCourseScalarWhereInput
  >;
}

export interface OpenUniversityCourseUpdateManyWithWhereNestedInput {
  where: OpenUniversityCourseScalarWhereInput;
  data: OpenUniversityCourseUpdateManyDataInput;
}

export interface OpenUniversityCourseUpdateManyDataInput {
  course_code?: Maybe<String>;
}

export interface CourseUpsertNestedInput {
  update: CourseUpdateDataInput;
  create: CourseCreateInput;
}

export interface CompletionUpdateOneRequiredInput {
  create?: Maybe<CompletionCreateInput>;
  update?: Maybe<CompletionUpdateDataInput>;
  upsert?: Maybe<CompletionUpsertNestedInput>;
  connect?: Maybe<CompletionWhereUniqueInput>;
}

export interface CompletionUpdateDataInput {
  user_upstream_id?: Maybe<Int>;
  email?: Maybe<String>;
  student_number?: Maybe<String>;
  user?: Maybe<UserUpdateOneRequiredWithoutCompletionsInput>;
  course?: Maybe<CourseUpdateOneRequiredInput>;
  completion_language?: Maybe<String>;
}

export interface CompletionUpsertNestedInput {
  update: CompletionUpdateDataInput;
  create: CompletionCreateInput;
}

export interface CompletionRegisteredUpsertWithWhereUniqueWithoutUserInput {
  where: CompletionRegisteredWhereUniqueInput;
  update: CompletionRegisteredUpdateWithoutUserDataInput;
  create: CompletionRegisteredCreateWithoutUserInput;
}

export interface CompletionRegisteredScalarWhereInput {
  id?: Maybe<UUID>;
  id_not?: Maybe<UUID>;
  id_in?: Maybe<UUID[] | UUID>;
  id_not_in?: Maybe<UUID[] | UUID>;
  id_lt?: Maybe<UUID>;
  id_lte?: Maybe<UUID>;
  id_gt?: Maybe<UUID>;
  id_gte?: Maybe<UUID>;
  id_contains?: Maybe<UUID>;
  id_not_contains?: Maybe<UUID>;
  id_starts_with?: Maybe<UUID>;
  id_not_starts_with?: Maybe<UUID>;
  id_ends_with?: Maybe<UUID>;
  id_not_ends_with?: Maybe<UUID>;
  created_at?: Maybe<DateTimeInput>;
  created_at_not?: Maybe<DateTimeInput>;
  created_at_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  created_at_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  created_at_lt?: Maybe<DateTimeInput>;
  created_at_lte?: Maybe<DateTimeInput>;
  created_at_gt?: Maybe<DateTimeInput>;
  created_at_gte?: Maybe<DateTimeInput>;
  updated_at?: Maybe<DateTimeInput>;
  updated_at_not?: Maybe<DateTimeInput>;
  updated_at_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updated_at_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updated_at_lt?: Maybe<DateTimeInput>;
  updated_at_lte?: Maybe<DateTimeInput>;
  updated_at_gt?: Maybe<DateTimeInput>;
  updated_at_gte?: Maybe<DateTimeInput>;
  real_student_number?: Maybe<String>;
  real_student_number_not?: Maybe<String>;
  real_student_number_in?: Maybe<String[] | String>;
  real_student_number_not_in?: Maybe<String[] | String>;
  real_student_number_lt?: Maybe<String>;
  real_student_number_lte?: Maybe<String>;
  real_student_number_gt?: Maybe<String>;
  real_student_number_gte?: Maybe<String>;
  real_student_number_contains?: Maybe<String>;
  real_student_number_not_contains?: Maybe<String>;
  real_student_number_starts_with?: Maybe<String>;
  real_student_number_not_starts_with?: Maybe<String>;
  real_student_number_ends_with?: Maybe<String>;
  real_student_number_not_ends_with?: Maybe<String>;
  organisation?: Maybe<String>;
  organisation_not?: Maybe<String>;
  organisation_in?: Maybe<String[] | String>;
  organisation_not_in?: Maybe<String[] | String>;
  organisation_lt?: Maybe<String>;
  organisation_lte?: Maybe<String>;
  organisation_gt?: Maybe<String>;
  organisation_gte?: Maybe<String>;
  organisation_contains?: Maybe<String>;
  organisation_not_contains?: Maybe<String>;
  organisation_starts_with?: Maybe<String>;
  organisation_not_starts_with?: Maybe<String>;
  organisation_ends_with?: Maybe<String>;
  organisation_not_ends_with?: Maybe<String>;
  AND?: Maybe<
    | CompletionRegisteredScalarWhereInput[]
    | CompletionRegisteredScalarWhereInput
  >;
  OR?: Maybe<
    | CompletionRegisteredScalarWhereInput[]
    | CompletionRegisteredScalarWhereInput
  >;
  NOT?: Maybe<
    | CompletionRegisteredScalarWhereInput[]
    | CompletionRegisteredScalarWhereInput
  >;
}

export interface CompletionRegisteredUpdateManyWithWhereNestedInput {
  where: CompletionRegisteredScalarWhereInput;
  data: CompletionRegisteredUpdateManyDataInput;
}

export interface CompletionRegisteredUpdateManyDataInput {
  real_student_number?: Maybe<String>;
  organisation?: Maybe<String>;
}

export interface UserUpsertWithoutCompletionsInput {
  update: UserUpdateWithoutCompletionsDataInput;
  create: UserCreateWithoutCompletionsInput;
}

export interface CompletionUpdateManyMutationInput {
  user_upstream_id?: Maybe<Int>;
  email?: Maybe<String>;
  student_number?: Maybe<String>;
  completion_language?: Maybe<String>;
}

export interface CompletionRegisteredCreateInput {
  id?: Maybe<UUID>;
  user: UserCreateOneWithoutRegistered_completionsInput;
  course: CourseCreateOneInput;
  real_student_number: String;
  organisation: String;
  completion: CompletionCreateOneInput;
}

export interface UserCreateOneWithoutRegistered_completionsInput {
  create?: Maybe<UserCreateWithoutRegistered_completionsInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserCreateWithoutRegistered_completionsInput {
  id?: Maybe<UUID>;
  upstream_id: Int;
  first_name?: Maybe<String>;
  last_name?: Maybe<String>;
  username: String;
  email: String;
  administrator: Boolean;
  student_number?: Maybe<String>;
  real_student_number?: Maybe<String>;
  completions?: Maybe<CompletionCreateManyWithoutUserInput>;
}

export interface CompletionCreateManyWithoutUserInput {
  create?: Maybe<
    CompletionCreateWithoutUserInput[] | CompletionCreateWithoutUserInput
  >;
  connect?: Maybe<CompletionWhereUniqueInput[] | CompletionWhereUniqueInput>;
}

export interface CompletionCreateWithoutUserInput {
  id?: Maybe<UUID>;
  user_upstream_id?: Maybe<Int>;
  email: String;
  student_number?: Maybe<String>;
  course: CourseCreateOneInput;
  completion_language?: Maybe<String>;
}

export interface CompletionRegisteredUpdateInput {
  user?: Maybe<UserUpdateOneRequiredWithoutRegistered_completionsInput>;
  course?: Maybe<CourseUpdateOneRequiredInput>;
  real_student_number?: Maybe<String>;
  organisation?: Maybe<String>;
  completion?: Maybe<CompletionUpdateOneRequiredInput>;
}

export interface UserUpdateOneRequiredWithoutRegistered_completionsInput {
  create?: Maybe<UserCreateWithoutRegistered_completionsInput>;
  update?: Maybe<UserUpdateWithoutRegistered_completionsDataInput>;
  upsert?: Maybe<UserUpsertWithoutRegistered_completionsInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserUpdateWithoutRegistered_completionsDataInput {
  upstream_id?: Maybe<Int>;
  first_name?: Maybe<String>;
  last_name?: Maybe<String>;
  username?: Maybe<String>;
  email?: Maybe<String>;
  administrator?: Maybe<Boolean>;
  student_number?: Maybe<String>;
  real_student_number?: Maybe<String>;
  completions?: Maybe<CompletionUpdateManyWithoutUserInput>;
}

export interface CompletionUpdateManyWithoutUserInput {
  create?: Maybe<
    CompletionCreateWithoutUserInput[] | CompletionCreateWithoutUserInput
  >;
  delete?: Maybe<CompletionWhereUniqueInput[] | CompletionWhereUniqueInput>;
  connect?: Maybe<CompletionWhereUniqueInput[] | CompletionWhereUniqueInput>;
  set?: Maybe<CompletionWhereUniqueInput[] | CompletionWhereUniqueInput>;
  disconnect?: Maybe<CompletionWhereUniqueInput[] | CompletionWhereUniqueInput>;
  update?: Maybe<
    | CompletionUpdateWithWhereUniqueWithoutUserInput[]
    | CompletionUpdateWithWhereUniqueWithoutUserInput
  >;
  upsert?: Maybe<
    | CompletionUpsertWithWhereUniqueWithoutUserInput[]
    | CompletionUpsertWithWhereUniqueWithoutUserInput
  >;
  deleteMany?: Maybe<CompletionScalarWhereInput[] | CompletionScalarWhereInput>;
  updateMany?: Maybe<
    | CompletionUpdateManyWithWhereNestedInput[]
    | CompletionUpdateManyWithWhereNestedInput
  >;
}

export interface CompletionUpdateWithWhereUniqueWithoutUserInput {
  where: CompletionWhereUniqueInput;
  data: CompletionUpdateWithoutUserDataInput;
}

export interface CompletionUpdateWithoutUserDataInput {
  user_upstream_id?: Maybe<Int>;
  email?: Maybe<String>;
  student_number?: Maybe<String>;
  course?: Maybe<CourseUpdateOneRequiredInput>;
  completion_language?: Maybe<String>;
}

export interface CompletionUpsertWithWhereUniqueWithoutUserInput {
  where: CompletionWhereUniqueInput;
  update: CompletionUpdateWithoutUserDataInput;
  create: CompletionCreateWithoutUserInput;
}

export interface CompletionScalarWhereInput {
  id?: Maybe<UUID>;
  id_not?: Maybe<UUID>;
  id_in?: Maybe<UUID[] | UUID>;
  id_not_in?: Maybe<UUID[] | UUID>;
  id_lt?: Maybe<UUID>;
  id_lte?: Maybe<UUID>;
  id_gt?: Maybe<UUID>;
  id_gte?: Maybe<UUID>;
  id_contains?: Maybe<UUID>;
  id_not_contains?: Maybe<UUID>;
  id_starts_with?: Maybe<UUID>;
  id_not_starts_with?: Maybe<UUID>;
  id_ends_with?: Maybe<UUID>;
  id_not_ends_with?: Maybe<UUID>;
  created_at?: Maybe<DateTimeInput>;
  created_at_not?: Maybe<DateTimeInput>;
  created_at_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  created_at_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  created_at_lt?: Maybe<DateTimeInput>;
  created_at_lte?: Maybe<DateTimeInput>;
  created_at_gt?: Maybe<DateTimeInput>;
  created_at_gte?: Maybe<DateTimeInput>;
  updated_at?: Maybe<DateTimeInput>;
  updated_at_not?: Maybe<DateTimeInput>;
  updated_at_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updated_at_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updated_at_lt?: Maybe<DateTimeInput>;
  updated_at_lte?: Maybe<DateTimeInput>;
  updated_at_gt?: Maybe<DateTimeInput>;
  updated_at_gte?: Maybe<DateTimeInput>;
  user_upstream_id?: Maybe<Int>;
  user_upstream_id_not?: Maybe<Int>;
  user_upstream_id_in?: Maybe<Int[] | Int>;
  user_upstream_id_not_in?: Maybe<Int[] | Int>;
  user_upstream_id_lt?: Maybe<Int>;
  user_upstream_id_lte?: Maybe<Int>;
  user_upstream_id_gt?: Maybe<Int>;
  user_upstream_id_gte?: Maybe<Int>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  student_number?: Maybe<String>;
  student_number_not?: Maybe<String>;
  student_number_in?: Maybe<String[] | String>;
  student_number_not_in?: Maybe<String[] | String>;
  student_number_lt?: Maybe<String>;
  student_number_lte?: Maybe<String>;
  student_number_gt?: Maybe<String>;
  student_number_gte?: Maybe<String>;
  student_number_contains?: Maybe<String>;
  student_number_not_contains?: Maybe<String>;
  student_number_starts_with?: Maybe<String>;
  student_number_not_starts_with?: Maybe<String>;
  student_number_ends_with?: Maybe<String>;
  student_number_not_ends_with?: Maybe<String>;
  completion_language?: Maybe<String>;
  completion_language_not?: Maybe<String>;
  completion_language_in?: Maybe<String[] | String>;
  completion_language_not_in?: Maybe<String[] | String>;
  completion_language_lt?: Maybe<String>;
  completion_language_lte?: Maybe<String>;
  completion_language_gt?: Maybe<String>;
  completion_language_gte?: Maybe<String>;
  completion_language_contains?: Maybe<String>;
  completion_language_not_contains?: Maybe<String>;
  completion_language_starts_with?: Maybe<String>;
  completion_language_not_starts_with?: Maybe<String>;
  completion_language_ends_with?: Maybe<String>;
  completion_language_not_ends_with?: Maybe<String>;
  AND?: Maybe<CompletionScalarWhereInput[] | CompletionScalarWhereInput>;
  OR?: Maybe<CompletionScalarWhereInput[] | CompletionScalarWhereInput>;
  NOT?: Maybe<CompletionScalarWhereInput[] | CompletionScalarWhereInput>;
}

export interface CompletionUpdateManyWithWhereNestedInput {
  where: CompletionScalarWhereInput;
  data: CompletionUpdateManyDataInput;
}

export interface CompletionUpdateManyDataInput {
  user_upstream_id?: Maybe<Int>;
  email?: Maybe<String>;
  student_number?: Maybe<String>;
  completion_language?: Maybe<String>;
}

export interface UserUpsertWithoutRegistered_completionsInput {
  update: UserUpdateWithoutRegistered_completionsDataInput;
  create: UserCreateWithoutRegistered_completionsInput;
}

export interface CompletionRegisteredUpdateManyMutationInput {
  real_student_number?: Maybe<String>;
  organisation?: Maybe<String>;
}

export interface CourseUpdateInput {
  name?: Maybe<String>;
  slug?: Maybe<String>;
  open_university_courses?: Maybe<
    OpenUniversityCourseUpdateManyWithoutCourseInput
  >;
}

export interface CourseUpdateManyMutationInput {
  name?: Maybe<String>;
  slug?: Maybe<String>;
}

export interface OpenUniversityCourseCreateInput {
  id?: Maybe<UUID>;
  course_code: String;
  course: CourseCreateOneWithoutOpen_university_coursesInput;
}

export interface CourseCreateOneWithoutOpen_university_coursesInput {
  create?: Maybe<CourseCreateWithoutOpen_university_coursesInput>;
  connect?: Maybe<CourseWhereUniqueInput>;
}

export interface CourseCreateWithoutOpen_university_coursesInput {
  id?: Maybe<UUID>;
  name: String;
  slug: String;
}

export interface OpenUniversityCourseUpdateInput {
  course_code?: Maybe<String>;
  course?: Maybe<CourseUpdateOneRequiredWithoutOpen_university_coursesInput>;
}

export interface CourseUpdateOneRequiredWithoutOpen_university_coursesInput {
  create?: Maybe<CourseCreateWithoutOpen_university_coursesInput>;
  update?: Maybe<CourseUpdateWithoutOpen_university_coursesDataInput>;
  upsert?: Maybe<CourseUpsertWithoutOpen_university_coursesInput>;
  connect?: Maybe<CourseWhereUniqueInput>;
}

export interface CourseUpdateWithoutOpen_university_coursesDataInput {
  name?: Maybe<String>;
  slug?: Maybe<String>;
}

export interface CourseUpsertWithoutOpen_university_coursesInput {
  update: CourseUpdateWithoutOpen_university_coursesDataInput;
  create: CourseCreateWithoutOpen_university_coursesInput;
}

export interface OpenUniversityCourseUpdateManyMutationInput {
  course_code?: Maybe<String>;
}

export interface UserCreateInput {
  id?: Maybe<UUID>;
  upstream_id: Int;
  first_name?: Maybe<String>;
  last_name?: Maybe<String>;
  username: String;
  email: String;
  administrator: Boolean;
  student_number?: Maybe<String>;
  real_student_number?: Maybe<String>;
  completions?: Maybe<CompletionCreateManyWithoutUserInput>;
  registered_completions?: Maybe<
    CompletionRegisteredCreateManyWithoutUserInput
  >;
}

export interface UserUpdateInput {
  upstream_id?: Maybe<Int>;
  first_name?: Maybe<String>;
  last_name?: Maybe<String>;
  username?: Maybe<String>;
  email?: Maybe<String>;
  administrator?: Maybe<Boolean>;
  student_number?: Maybe<String>;
  real_student_number?: Maybe<String>;
  completions?: Maybe<CompletionUpdateManyWithoutUserInput>;
  registered_completions?: Maybe<
    CompletionRegisteredUpdateManyWithoutUserInput
  >;
}

export interface UserUpdateManyMutationInput {
  upstream_id?: Maybe<Int>;
  first_name?: Maybe<String>;
  last_name?: Maybe<String>;
  username?: Maybe<String>;
  email?: Maybe<String>;
  administrator?: Maybe<Boolean>;
  student_number?: Maybe<String>;
  real_student_number?: Maybe<String>;
}

export interface CompletionSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<CompletionWhereInput>;
  AND?: Maybe<
    CompletionSubscriptionWhereInput[] | CompletionSubscriptionWhereInput
  >;
  OR?: Maybe<
    CompletionSubscriptionWhereInput[] | CompletionSubscriptionWhereInput
  >;
  NOT?: Maybe<
    CompletionSubscriptionWhereInput[] | CompletionSubscriptionWhereInput
  >;
}

export interface CompletionRegisteredSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<CompletionRegisteredWhereInput>;
  AND?: Maybe<
    | CompletionRegisteredSubscriptionWhereInput[]
    | CompletionRegisteredSubscriptionWhereInput
  >;
  OR?: Maybe<
    | CompletionRegisteredSubscriptionWhereInput[]
    | CompletionRegisteredSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | CompletionRegisteredSubscriptionWhereInput[]
    | CompletionRegisteredSubscriptionWhereInput
  >;
}

export interface CourseSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<CourseWhereInput>;
  AND?: Maybe<CourseSubscriptionWhereInput[] | CourseSubscriptionWhereInput>;
  OR?: Maybe<CourseSubscriptionWhereInput[] | CourseSubscriptionWhereInput>;
  NOT?: Maybe<CourseSubscriptionWhereInput[] | CourseSubscriptionWhereInput>;
}

export interface OpenUniversityCourseSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<OpenUniversityCourseWhereInput>;
  AND?: Maybe<
    | OpenUniversityCourseSubscriptionWhereInput[]
    | OpenUniversityCourseSubscriptionWhereInput
  >;
  OR?: Maybe<
    | OpenUniversityCourseSubscriptionWhereInput[]
    | OpenUniversityCourseSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | OpenUniversityCourseSubscriptionWhereInput[]
    | OpenUniversityCourseSubscriptionWhereInput
  >;
}

export interface UserSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<UserWhereInput>;
  AND?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
  OR?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
  NOT?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
}

export interface NodeNode {
  id: ID_Output;
}

export interface Completion {
  id: UUID;
  created_at: DateTimeOutput;
  updated_at: DateTimeOutput;
  user_upstream_id?: Int;
  email: String;
  student_number?: String;
  completion_language?: String;
}

export interface CompletionPromise extends Promise<Completion>, Fragmentable {
  id: () => Promise<UUID>;
  created_at: () => Promise<DateTimeOutput>;
  updated_at: () => Promise<DateTimeOutput>;
  user_upstream_id: () => Promise<Int>;
  email: () => Promise<String>;
  student_number: () => Promise<String>;
  user: <T = UserPromise>() => T;
  course: <T = CoursePromise>() => T;
  completion_language: () => Promise<String>;
}

export interface CompletionSubscription
  extends Promise<AsyncIterator<Completion>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<UUID>>;
  created_at: () => Promise<AsyncIterator<DateTimeOutput>>;
  updated_at: () => Promise<AsyncIterator<DateTimeOutput>>;
  user_upstream_id: () => Promise<AsyncIterator<Int>>;
  email: () => Promise<AsyncIterator<String>>;
  student_number: () => Promise<AsyncIterator<String>>;
  user: <T = UserSubscription>() => T;
  course: <T = CourseSubscription>() => T;
  completion_language: () => Promise<AsyncIterator<String>>;
}

export interface CompletionNullablePromise
  extends Promise<Completion | null>,
    Fragmentable {
  id: () => Promise<UUID>;
  created_at: () => Promise<DateTimeOutput>;
  updated_at: () => Promise<DateTimeOutput>;
  user_upstream_id: () => Promise<Int>;
  email: () => Promise<String>;
  student_number: () => Promise<String>;
  user: <T = UserPromise>() => T;
  course: <T = CoursePromise>() => T;
  completion_language: () => Promise<String>;
}

export interface User {
  id: UUID;
  upstream_id: Int;
  created_at: DateTimeOutput;
  updated_at: DateTimeOutput;
  first_name?: String;
  last_name?: String;
  username: String;
  email: String;
  administrator: Boolean;
  student_number?: String;
  real_student_number?: String;
}

export interface UserPromise extends Promise<User>, Fragmentable {
  id: () => Promise<UUID>;
  upstream_id: () => Promise<Int>;
  created_at: () => Promise<DateTimeOutput>;
  updated_at: () => Promise<DateTimeOutput>;
  first_name: () => Promise<String>;
  last_name: () => Promise<String>;
  username: () => Promise<String>;
  email: () => Promise<String>;
  administrator: () => Promise<Boolean>;
  student_number: () => Promise<String>;
  real_student_number: () => Promise<String>;
  completions: <T = FragmentableArray<Completion>>(args?: {
    where?: CompletionWhereInput;
    orderBy?: CompletionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  registered_completions: <T = FragmentableArray<CompletionRegistered>>(args?: {
    where?: CompletionRegisteredWhereInput;
    orderBy?: CompletionRegisteredOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface UserSubscription
  extends Promise<AsyncIterator<User>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<UUID>>;
  upstream_id: () => Promise<AsyncIterator<Int>>;
  created_at: () => Promise<AsyncIterator<DateTimeOutput>>;
  updated_at: () => Promise<AsyncIterator<DateTimeOutput>>;
  first_name: () => Promise<AsyncIterator<String>>;
  last_name: () => Promise<AsyncIterator<String>>;
  username: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  administrator: () => Promise<AsyncIterator<Boolean>>;
  student_number: () => Promise<AsyncIterator<String>>;
  real_student_number: () => Promise<AsyncIterator<String>>;
  completions: <T = Promise<AsyncIterator<CompletionSubscription>>>(args?: {
    where?: CompletionWhereInput;
    orderBy?: CompletionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  registered_completions: <
    T = Promise<AsyncIterator<CompletionRegisteredSubscription>>
  >(args?: {
    where?: CompletionRegisteredWhereInput;
    orderBy?: CompletionRegisteredOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface UserNullablePromise
  extends Promise<User | null>,
    Fragmentable {
  id: () => Promise<UUID>;
  upstream_id: () => Promise<Int>;
  created_at: () => Promise<DateTimeOutput>;
  updated_at: () => Promise<DateTimeOutput>;
  first_name: () => Promise<String>;
  last_name: () => Promise<String>;
  username: () => Promise<String>;
  email: () => Promise<String>;
  administrator: () => Promise<Boolean>;
  student_number: () => Promise<String>;
  real_student_number: () => Promise<String>;
  completions: <T = FragmentableArray<Completion>>(args?: {
    where?: CompletionWhereInput;
    orderBy?: CompletionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  registered_completions: <T = FragmentableArray<CompletionRegistered>>(args?: {
    where?: CompletionRegisteredWhereInput;
    orderBy?: CompletionRegisteredOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface CompletionRegistered {
  id: UUID;
  created_at: DateTimeOutput;
  updated_at: DateTimeOutput;
  real_student_number: String;
  organisation: String;
}

export interface CompletionRegisteredPromise
  extends Promise<CompletionRegistered>,
    Fragmentable {
  id: () => Promise<UUID>;
  created_at: () => Promise<DateTimeOutput>;
  updated_at: () => Promise<DateTimeOutput>;
  user: <T = UserPromise>() => T;
  course: <T = CoursePromise>() => T;
  real_student_number: () => Promise<String>;
  organisation: () => Promise<String>;
  completion: <T = CompletionPromise>() => T;
}

export interface CompletionRegisteredSubscription
  extends Promise<AsyncIterator<CompletionRegistered>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<UUID>>;
  created_at: () => Promise<AsyncIterator<DateTimeOutput>>;
  updated_at: () => Promise<AsyncIterator<DateTimeOutput>>;
  user: <T = UserSubscription>() => T;
  course: <T = CourseSubscription>() => T;
  real_student_number: () => Promise<AsyncIterator<String>>;
  organisation: () => Promise<AsyncIterator<String>>;
  completion: <T = CompletionSubscription>() => T;
}

export interface CompletionRegisteredNullablePromise
  extends Promise<CompletionRegistered | null>,
    Fragmentable {
  id: () => Promise<UUID>;
  created_at: () => Promise<DateTimeOutput>;
  updated_at: () => Promise<DateTimeOutput>;
  user: <T = UserPromise>() => T;
  course: <T = CoursePromise>() => T;
  real_student_number: () => Promise<String>;
  organisation: () => Promise<String>;
  completion: <T = CompletionPromise>() => T;
}

export interface Course {
  id: UUID;
  created_at: DateTimeOutput;
  updated_at: DateTimeOutput;
  name: String;
  slug: String;
}

export interface CoursePromise extends Promise<Course>, Fragmentable {
  id: () => Promise<UUID>;
  created_at: () => Promise<DateTimeOutput>;
  updated_at: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
  slug: () => Promise<String>;
  open_university_courses: <
    T = FragmentableArray<OpenUniversityCourse>
  >(args?: {
    where?: OpenUniversityCourseWhereInput;
    orderBy?: OpenUniversityCourseOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface CourseSubscription
  extends Promise<AsyncIterator<Course>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<UUID>>;
  created_at: () => Promise<AsyncIterator<DateTimeOutput>>;
  updated_at: () => Promise<AsyncIterator<DateTimeOutput>>;
  name: () => Promise<AsyncIterator<String>>;
  slug: () => Promise<AsyncIterator<String>>;
  open_university_courses: <
    T = Promise<AsyncIterator<OpenUniversityCourseSubscription>>
  >(args?: {
    where?: OpenUniversityCourseWhereInput;
    orderBy?: OpenUniversityCourseOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface CourseNullablePromise
  extends Promise<Course | null>,
    Fragmentable {
  id: () => Promise<UUID>;
  created_at: () => Promise<DateTimeOutput>;
  updated_at: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
  slug: () => Promise<String>;
  open_university_courses: <
    T = FragmentableArray<OpenUniversityCourse>
  >(args?: {
    where?: OpenUniversityCourseWhereInput;
    orderBy?: OpenUniversityCourseOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface OpenUniversityCourse {
  id: UUID;
  created_at: DateTimeOutput;
  updated_at: DateTimeOutput;
  course_code: String;
}

export interface OpenUniversityCoursePromise
  extends Promise<OpenUniversityCourse>,
    Fragmentable {
  id: () => Promise<UUID>;
  created_at: () => Promise<DateTimeOutput>;
  updated_at: () => Promise<DateTimeOutput>;
  course_code: () => Promise<String>;
  course: <T = CoursePromise>() => T;
}

export interface OpenUniversityCourseSubscription
  extends Promise<AsyncIterator<OpenUniversityCourse>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<UUID>>;
  created_at: () => Promise<AsyncIterator<DateTimeOutput>>;
  updated_at: () => Promise<AsyncIterator<DateTimeOutput>>;
  course_code: () => Promise<AsyncIterator<String>>;
  course: <T = CourseSubscription>() => T;
}

export interface OpenUniversityCourseNullablePromise
  extends Promise<OpenUniversityCourse | null>,
    Fragmentable {
  id: () => Promise<UUID>;
  created_at: () => Promise<DateTimeOutput>;
  updated_at: () => Promise<DateTimeOutput>;
  course_code: () => Promise<String>;
  course: <T = CoursePromise>() => T;
}

export interface CompletionConnection {
  pageInfo: PageInfo;
  edges: CompletionEdge[];
}

export interface CompletionConnectionPromise
  extends Promise<CompletionConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CompletionEdge>>() => T;
  aggregate: <T = AggregateCompletionPromise>() => T;
}

export interface CompletionConnectionSubscription
  extends Promise<AsyncIterator<CompletionConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CompletionEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCompletionSubscription>() => T;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface CompletionEdge {
  node: Completion;
  cursor: String;
}

export interface CompletionEdgePromise
  extends Promise<CompletionEdge>,
    Fragmentable {
  node: <T = CompletionPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CompletionEdgeSubscription
  extends Promise<AsyncIterator<CompletionEdge>>,
    Fragmentable {
  node: <T = CompletionSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateCompletion {
  count: Int;
}

export interface AggregateCompletionPromise
  extends Promise<AggregateCompletion>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCompletionSubscription
  extends Promise<AsyncIterator<AggregateCompletion>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CompletionRegisteredConnection {
  pageInfo: PageInfo;
  edges: CompletionRegisteredEdge[];
}

export interface CompletionRegisteredConnectionPromise
  extends Promise<CompletionRegisteredConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CompletionRegisteredEdge>>() => T;
  aggregate: <T = AggregateCompletionRegisteredPromise>() => T;
}

export interface CompletionRegisteredConnectionSubscription
  extends Promise<AsyncIterator<CompletionRegisteredConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<CompletionRegisteredEdgeSubscription>>
  >() => T;
  aggregate: <T = AggregateCompletionRegisteredSubscription>() => T;
}

export interface CompletionRegisteredEdge {
  node: CompletionRegistered;
  cursor: String;
}

export interface CompletionRegisteredEdgePromise
  extends Promise<CompletionRegisteredEdge>,
    Fragmentable {
  node: <T = CompletionRegisteredPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CompletionRegisteredEdgeSubscription
  extends Promise<AsyncIterator<CompletionRegisteredEdge>>,
    Fragmentable {
  node: <T = CompletionRegisteredSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateCompletionRegistered {
  count: Int;
}

export interface AggregateCompletionRegisteredPromise
  extends Promise<AggregateCompletionRegistered>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCompletionRegisteredSubscription
  extends Promise<AsyncIterator<AggregateCompletionRegistered>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CourseConnection {
  pageInfo: PageInfo;
  edges: CourseEdge[];
}

export interface CourseConnectionPromise
  extends Promise<CourseConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CourseEdge>>() => T;
  aggregate: <T = AggregateCoursePromise>() => T;
}

export interface CourseConnectionSubscription
  extends Promise<AsyncIterator<CourseConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CourseEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCourseSubscription>() => T;
}

export interface CourseEdge {
  node: Course;
  cursor: String;
}

export interface CourseEdgePromise extends Promise<CourseEdge>, Fragmentable {
  node: <T = CoursePromise>() => T;
  cursor: () => Promise<String>;
}

export interface CourseEdgeSubscription
  extends Promise<AsyncIterator<CourseEdge>>,
    Fragmentable {
  node: <T = CourseSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateCourse {
  count: Int;
}

export interface AggregateCoursePromise
  extends Promise<AggregateCourse>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCourseSubscription
  extends Promise<AsyncIterator<AggregateCourse>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface OpenUniversityCourseConnection {
  pageInfo: PageInfo;
  edges: OpenUniversityCourseEdge[];
}

export interface OpenUniversityCourseConnectionPromise
  extends Promise<OpenUniversityCourseConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<OpenUniversityCourseEdge>>() => T;
  aggregate: <T = AggregateOpenUniversityCoursePromise>() => T;
}

export interface OpenUniversityCourseConnectionSubscription
  extends Promise<AsyncIterator<OpenUniversityCourseConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<OpenUniversityCourseEdgeSubscription>>
  >() => T;
  aggregate: <T = AggregateOpenUniversityCourseSubscription>() => T;
}

export interface OpenUniversityCourseEdge {
  node: OpenUniversityCourse;
  cursor: String;
}

export interface OpenUniversityCourseEdgePromise
  extends Promise<OpenUniversityCourseEdge>,
    Fragmentable {
  node: <T = OpenUniversityCoursePromise>() => T;
  cursor: () => Promise<String>;
}

export interface OpenUniversityCourseEdgeSubscription
  extends Promise<AsyncIterator<OpenUniversityCourseEdge>>,
    Fragmentable {
  node: <T = OpenUniversityCourseSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateOpenUniversityCourse {
  count: Int;
}

export interface AggregateOpenUniversityCoursePromise
  extends Promise<AggregateOpenUniversityCourse>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateOpenUniversityCourseSubscription
  extends Promise<AsyncIterator<AggregateOpenUniversityCourse>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface UserConnection {
  pageInfo: PageInfo;
  edges: UserEdge[];
}

export interface UserConnectionPromise
  extends Promise<UserConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserEdge>>() => T;
  aggregate: <T = AggregateUserPromise>() => T;
}

export interface UserConnectionSubscription
  extends Promise<AsyncIterator<UserConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserSubscription>() => T;
}

export interface UserEdge {
  node: User;
  cursor: String;
}

export interface UserEdgePromise extends Promise<UserEdge>, Fragmentable {
  node: <T = UserPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserEdgeSubscription
  extends Promise<AsyncIterator<UserEdge>>,
    Fragmentable {
  node: <T = UserSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateUser {
  count: Int;
}

export interface AggregateUserPromise
  extends Promise<AggregateUser>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserSubscription
  extends Promise<AsyncIterator<AggregateUser>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface CompletionSubscriptionPayload {
  mutation: MutationType;
  node: Completion;
  updatedFields: String[];
  previousValues: CompletionPreviousValues;
}

export interface CompletionSubscriptionPayloadPromise
  extends Promise<CompletionSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CompletionPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CompletionPreviousValuesPromise>() => T;
}

export interface CompletionSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CompletionSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CompletionSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CompletionPreviousValuesSubscription>() => T;
}

export interface CompletionPreviousValues {
  id: UUID;
  created_at: DateTimeOutput;
  updated_at: DateTimeOutput;
  user_upstream_id?: Int;
  email: String;
  student_number?: String;
  completion_language?: String;
}

export interface CompletionPreviousValuesPromise
  extends Promise<CompletionPreviousValues>,
    Fragmentable {
  id: () => Promise<UUID>;
  created_at: () => Promise<DateTimeOutput>;
  updated_at: () => Promise<DateTimeOutput>;
  user_upstream_id: () => Promise<Int>;
  email: () => Promise<String>;
  student_number: () => Promise<String>;
  completion_language: () => Promise<String>;
}

export interface CompletionPreviousValuesSubscription
  extends Promise<AsyncIterator<CompletionPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<UUID>>;
  created_at: () => Promise<AsyncIterator<DateTimeOutput>>;
  updated_at: () => Promise<AsyncIterator<DateTimeOutput>>;
  user_upstream_id: () => Promise<AsyncIterator<Int>>;
  email: () => Promise<AsyncIterator<String>>;
  student_number: () => Promise<AsyncIterator<String>>;
  completion_language: () => Promise<AsyncIterator<String>>;
}

export interface CompletionRegisteredSubscriptionPayload {
  mutation: MutationType;
  node: CompletionRegistered;
  updatedFields: String[];
  previousValues: CompletionRegisteredPreviousValues;
}

export interface CompletionRegisteredSubscriptionPayloadPromise
  extends Promise<CompletionRegisteredSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CompletionRegisteredPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CompletionRegisteredPreviousValuesPromise>() => T;
}

export interface CompletionRegisteredSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CompletionRegisteredSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CompletionRegisteredSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CompletionRegisteredPreviousValuesSubscription>() => T;
}

export interface CompletionRegisteredPreviousValues {
  id: UUID;
  created_at: DateTimeOutput;
  updated_at: DateTimeOutput;
  real_student_number: String;
  organisation: String;
}

export interface CompletionRegisteredPreviousValuesPromise
  extends Promise<CompletionRegisteredPreviousValues>,
    Fragmentable {
  id: () => Promise<UUID>;
  created_at: () => Promise<DateTimeOutput>;
  updated_at: () => Promise<DateTimeOutput>;
  real_student_number: () => Promise<String>;
  organisation: () => Promise<String>;
}

export interface CompletionRegisteredPreviousValuesSubscription
  extends Promise<AsyncIterator<CompletionRegisteredPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<UUID>>;
  created_at: () => Promise<AsyncIterator<DateTimeOutput>>;
  updated_at: () => Promise<AsyncIterator<DateTimeOutput>>;
  real_student_number: () => Promise<AsyncIterator<String>>;
  organisation: () => Promise<AsyncIterator<String>>;
}

export interface CourseSubscriptionPayload {
  mutation: MutationType;
  node: Course;
  updatedFields: String[];
  previousValues: CoursePreviousValues;
}

export interface CourseSubscriptionPayloadPromise
  extends Promise<CourseSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CoursePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CoursePreviousValuesPromise>() => T;
}

export interface CourseSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CourseSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CourseSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CoursePreviousValuesSubscription>() => T;
}

export interface CoursePreviousValues {
  id: UUID;
  created_at: DateTimeOutput;
  updated_at: DateTimeOutput;
  name: String;
  slug: String;
}

export interface CoursePreviousValuesPromise
  extends Promise<CoursePreviousValues>,
    Fragmentable {
  id: () => Promise<UUID>;
  created_at: () => Promise<DateTimeOutput>;
  updated_at: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
  slug: () => Promise<String>;
}

export interface CoursePreviousValuesSubscription
  extends Promise<AsyncIterator<CoursePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<UUID>>;
  created_at: () => Promise<AsyncIterator<DateTimeOutput>>;
  updated_at: () => Promise<AsyncIterator<DateTimeOutput>>;
  name: () => Promise<AsyncIterator<String>>;
  slug: () => Promise<AsyncIterator<String>>;
}

export interface OpenUniversityCourseSubscriptionPayload {
  mutation: MutationType;
  node: OpenUniversityCourse;
  updatedFields: String[];
  previousValues: OpenUniversityCoursePreviousValues;
}

export interface OpenUniversityCourseSubscriptionPayloadPromise
  extends Promise<OpenUniversityCourseSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = OpenUniversityCoursePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = OpenUniversityCoursePreviousValuesPromise>() => T;
}

export interface OpenUniversityCourseSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<OpenUniversityCourseSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = OpenUniversityCourseSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = OpenUniversityCoursePreviousValuesSubscription>() => T;
}

export interface OpenUniversityCoursePreviousValues {
  id: UUID;
  created_at: DateTimeOutput;
  updated_at: DateTimeOutput;
  course_code: String;
}

export interface OpenUniversityCoursePreviousValuesPromise
  extends Promise<OpenUniversityCoursePreviousValues>,
    Fragmentable {
  id: () => Promise<UUID>;
  created_at: () => Promise<DateTimeOutput>;
  updated_at: () => Promise<DateTimeOutput>;
  course_code: () => Promise<String>;
}

export interface OpenUniversityCoursePreviousValuesSubscription
  extends Promise<AsyncIterator<OpenUniversityCoursePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<UUID>>;
  created_at: () => Promise<AsyncIterator<DateTimeOutput>>;
  updated_at: () => Promise<AsyncIterator<DateTimeOutput>>;
  course_code: () => Promise<AsyncIterator<String>>;
}

export interface UserSubscriptionPayload {
  mutation: MutationType;
  node: User;
  updatedFields: String[];
  previousValues: UserPreviousValues;
}

export interface UserSubscriptionPayloadPromise
  extends Promise<UserSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserPreviousValuesPromise>() => T;
}

export interface UserSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserPreviousValuesSubscription>() => T;
}

export interface UserPreviousValues {
  id: UUID;
  upstream_id: Int;
  created_at: DateTimeOutput;
  updated_at: DateTimeOutput;
  first_name?: String;
  last_name?: String;
  username: String;
  email: String;
  administrator: Boolean;
  student_number?: String;
  real_student_number?: String;
}

export interface UserPreviousValuesPromise
  extends Promise<UserPreviousValues>,
    Fragmentable {
  id: () => Promise<UUID>;
  upstream_id: () => Promise<Int>;
  created_at: () => Promise<DateTimeOutput>;
  updated_at: () => Promise<DateTimeOutput>;
  first_name: () => Promise<String>;
  last_name: () => Promise<String>;
  username: () => Promise<String>;
  email: () => Promise<String>;
  administrator: () => Promise<Boolean>;
  student_number: () => Promise<String>;
  real_student_number: () => Promise<String>;
}

export interface UserPreviousValuesSubscription
  extends Promise<AsyncIterator<UserPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<UUID>>;
  upstream_id: () => Promise<AsyncIterator<Int>>;
  created_at: () => Promise<AsyncIterator<DateTimeOutput>>;
  updated_at: () => Promise<AsyncIterator<DateTimeOutput>>;
  first_name: () => Promise<AsyncIterator<String>>;
  last_name: () => Promise<AsyncIterator<String>>;
  username: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  administrator: () => Promise<AsyncIterator<Boolean>>;
  student_number: () => Promise<AsyncIterator<String>>;
  real_student_number: () => Promise<AsyncIterator<String>>;
}

export type UUID = string;

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1. 
*/
export type Int = number;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

export type Long = string;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "User",
    embedded: false
  },
  {
    name: "Course",
    embedded: false
  },
  {
    name: "OpenUniversityCourse",
    embedded: false
  },
  {
    name: "Completion",
    embedded: false
  },
  {
    name: "CompletionRegistered",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const Prisma = makePrismaClientClass<ClientConstructor<Prisma>>({
  typeDefs,
  models,
  endpoint: `http://localhost:4466`
});
export const prisma = new Prisma();
