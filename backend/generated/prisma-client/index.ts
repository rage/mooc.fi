// Code generated by Prisma (prisma@1.30.2). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export interface Exists {
  completion: (where?: CompletionWhereInput) => Promise<boolean>;
  completionRegistered: (
    where?: CompletionRegisteredWhereInput
  ) => Promise<boolean>;
  course: (where?: CourseWhereInput) => Promise<boolean>;
  courseAlias: (where?: CourseAliasWhereInput) => Promise<boolean>;
  service: (where?: ServiceWhereInput) => Promise<boolean>;
  user: (where?: UserWhereInput) => Promise<boolean>;
  userCourseProgress: (
    where?: UserCourseProgressWhereInput
  ) => Promise<boolean>;
  userCourseServiceProgress: (
    where?: UserCourseServiceProgressWhereInput
  ) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  completion: (where: CompletionWhereUniqueInput) => CompletionPromise;
  completions: (
    args?: {
      where?: CompletionWhereInput;
      orderBy?: CompletionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Completion>;
  completionsConnection: (
    args?: {
      where?: CompletionWhereInput;
      orderBy?: CompletionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => CompletionConnectionPromise;
  completionRegistered: (
    where: CompletionRegisteredWhereUniqueInput
  ) => CompletionRegisteredPromise;
  completionRegistereds: (
    args?: {
      where?: CompletionRegisteredWhereInput;
      orderBy?: CompletionRegisteredOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<CompletionRegistered>;
  completionRegisteredsConnection: (
    args?: {
      where?: CompletionRegisteredWhereInput;
      orderBy?: CompletionRegisteredOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => CompletionRegisteredConnectionPromise;
  course: (where: CourseWhereUniqueInput) => CoursePromise;
  courses: (
    args?: {
      where?: CourseWhereInput;
      orderBy?: CourseOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Course>;
  coursesConnection: (
    args?: {
      where?: CourseWhereInput;
      orderBy?: CourseOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => CourseConnectionPromise;
  courseAlias: (where: CourseAliasWhereUniqueInput) => CourseAliasPromise;
  courseAliases: (
    args?: {
      where?: CourseAliasWhereInput;
      orderBy?: CourseAliasOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<CourseAlias>;
  courseAliasesConnection: (
    args?: {
      where?: CourseAliasWhereInput;
      orderBy?: CourseAliasOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => CourseAliasConnectionPromise;
  service: (where: ServiceWhereUniqueInput) => ServicePromise;
  services: (
    args?: {
      where?: ServiceWhereInput;
      orderBy?: ServiceOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Service>;
  servicesConnection: (
    args?: {
      where?: ServiceWhereInput;
      orderBy?: ServiceOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => ServiceConnectionPromise;
  user: (where: UserWhereUniqueInput) => UserPromise;
  users: (
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<User>;
  usersConnection: (
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => UserConnectionPromise;
  userCourseProgress: (
    where: UserCourseProgressWhereUniqueInput
  ) => UserCourseProgressPromise;
  userCourseProgresses: (
    args?: {
      where?: UserCourseProgressWhereInput;
      orderBy?: UserCourseProgressOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<UserCourseProgress>;
  userCourseProgressesConnection: (
    args?: {
      where?: UserCourseProgressWhereInput;
      orderBy?: UserCourseProgressOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => UserCourseProgressConnectionPromise;
  userCourseServiceProgress: (
    where: UserCourseServiceProgressWhereUniqueInput
  ) => UserCourseServiceProgressPromise;
  userCourseServiceProgresses: (
    args?: {
      where?: UserCourseServiceProgressWhereInput;
      orderBy?: UserCourseServiceProgressOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<UserCourseServiceProgress>;
  userCourseServiceProgressesConnection: (
    args?: {
      where?: UserCourseServiceProgressWhereInput;
      orderBy?: UserCourseServiceProgressOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => UserCourseServiceProgressConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createCompletion: (data: CompletionCreateInput) => CompletionPromise;
  updateCompletion: (
    args: { data: CompletionUpdateInput; where: CompletionWhereUniqueInput }
  ) => CompletionPromise;
  updateManyCompletions: (
    args: {
      data: CompletionUpdateManyMutationInput;
      where?: CompletionWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertCompletion: (
    args: {
      where: CompletionWhereUniqueInput;
      create: CompletionCreateInput;
      update: CompletionUpdateInput;
    }
  ) => CompletionPromise;
  deleteCompletion: (where: CompletionWhereUniqueInput) => CompletionPromise;
  deleteManyCompletions: (where?: CompletionWhereInput) => BatchPayloadPromise;
  createCompletionRegistered: (
    data: CompletionRegisteredCreateInput
  ) => CompletionRegisteredPromise;
  updateCompletionRegistered: (
    args: {
      data: CompletionRegisteredUpdateInput;
      where: CompletionRegisteredWhereUniqueInput;
    }
  ) => CompletionRegisteredPromise;
  updateManyCompletionRegistereds: (
    args: {
      data: CompletionRegisteredUpdateManyMutationInput;
      where?: CompletionRegisteredWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertCompletionRegistered: (
    args: {
      where: CompletionRegisteredWhereUniqueInput;
      create: CompletionRegisteredCreateInput;
      update: CompletionRegisteredUpdateInput;
    }
  ) => CompletionRegisteredPromise;
  deleteCompletionRegistered: (
    where: CompletionRegisteredWhereUniqueInput
  ) => CompletionRegisteredPromise;
  deleteManyCompletionRegistereds: (
    where?: CompletionRegisteredWhereInput
  ) => BatchPayloadPromise;
  createCourse: (data: CourseCreateInput) => CoursePromise;
  updateCourse: (
    args: { data: CourseUpdateInput; where: CourseWhereUniqueInput }
  ) => CoursePromise;
  updateManyCourses: (
    args: { data: CourseUpdateManyMutationInput; where?: CourseWhereInput }
  ) => BatchPayloadPromise;
  upsertCourse: (
    args: {
      where: CourseWhereUniqueInput;
      create: CourseCreateInput;
      update: CourseUpdateInput;
    }
  ) => CoursePromise;
  deleteCourse: (where: CourseWhereUniqueInput) => CoursePromise;
  deleteManyCourses: (where?: CourseWhereInput) => BatchPayloadPromise;
  createCourseAlias: (data: CourseAliasCreateInput) => CourseAliasPromise;
  updateCourseAlias: (
    args: { data: CourseAliasUpdateInput; where: CourseAliasWhereUniqueInput }
  ) => CourseAliasPromise;
  updateManyCourseAliases: (
    args: {
      data: CourseAliasUpdateManyMutationInput;
      where?: CourseAliasWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertCourseAlias: (
    args: {
      where: CourseAliasWhereUniqueInput;
      create: CourseAliasCreateInput;
      update: CourseAliasUpdateInput;
    }
  ) => CourseAliasPromise;
  deleteCourseAlias: (where: CourseAliasWhereUniqueInput) => CourseAliasPromise;
  deleteManyCourseAliases: (
    where?: CourseAliasWhereInput
  ) => BatchPayloadPromise;
  createService: (data: ServiceCreateInput) => ServicePromise;
  updateService: (
    args: { data: ServiceUpdateInput; where: ServiceWhereUniqueInput }
  ) => ServicePromise;
  updateManyServices: (
    args: { data: ServiceUpdateManyMutationInput; where?: ServiceWhereInput }
  ) => BatchPayloadPromise;
  upsertService: (
    args: {
      where: ServiceWhereUniqueInput;
      create: ServiceCreateInput;
      update: ServiceUpdateInput;
    }
  ) => ServicePromise;
  deleteService: (where: ServiceWhereUniqueInput) => ServicePromise;
  deleteManyServices: (where?: ServiceWhereInput) => BatchPayloadPromise;
  createUser: (data: UserCreateInput) => UserPromise;
  updateUser: (
    args: { data: UserUpdateInput; where: UserWhereUniqueInput }
  ) => UserPromise;
  updateManyUsers: (
    args: { data: UserUpdateManyMutationInput; where?: UserWhereInput }
  ) => BatchPayloadPromise;
  upsertUser: (
    args: {
      where: UserWhereUniqueInput;
      create: UserCreateInput;
      update: UserUpdateInput;
    }
  ) => UserPromise;
  deleteUser: (where: UserWhereUniqueInput) => UserPromise;
  deleteManyUsers: (where?: UserWhereInput) => BatchPayloadPromise;
  createUserCourseProgress: (
    data: UserCourseProgressCreateInput
  ) => UserCourseProgressPromise;
  updateUserCourseProgress: (
    args: {
      data: UserCourseProgressUpdateInput;
      where: UserCourseProgressWhereUniqueInput;
    }
  ) => UserCourseProgressPromise;
  updateManyUserCourseProgresses: (
    args: {
      data: UserCourseProgressUpdateManyMutationInput;
      where?: UserCourseProgressWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertUserCourseProgress: (
    args: {
      where: UserCourseProgressWhereUniqueInput;
      create: UserCourseProgressCreateInput;
      update: UserCourseProgressUpdateInput;
    }
  ) => UserCourseProgressPromise;
  deleteUserCourseProgress: (
    where: UserCourseProgressWhereUniqueInput
  ) => UserCourseProgressPromise;
  deleteManyUserCourseProgresses: (
    where?: UserCourseProgressWhereInput
  ) => BatchPayloadPromise;
  createUserCourseServiceProgress: (
    data: UserCourseServiceProgressCreateInput
  ) => UserCourseServiceProgressPromise;
  updateUserCourseServiceProgress: (
    args: {
      data: UserCourseServiceProgressUpdateInput;
      where: UserCourseServiceProgressWhereUniqueInput;
    }
  ) => UserCourseServiceProgressPromise;
  updateManyUserCourseServiceProgresses: (
    args: {
      data: UserCourseServiceProgressUpdateManyMutationInput;
      where?: UserCourseServiceProgressWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertUserCourseServiceProgress: (
    args: {
      where: UserCourseServiceProgressWhereUniqueInput;
      create: UserCourseServiceProgressCreateInput;
      update: UserCourseServiceProgressUpdateInput;
    }
  ) => UserCourseServiceProgressPromise;
  deleteUserCourseServiceProgress: (
    where: UserCourseServiceProgressWhereUniqueInput
  ) => UserCourseServiceProgressPromise;
  deleteManyUserCourseServiceProgresses: (
    where?: UserCourseServiceProgressWhereInput
  ) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  completion: (
    where?: CompletionSubscriptionWhereInput
  ) => CompletionSubscriptionPayloadSubscription;
  completionRegistered: (
    where?: CompletionRegisteredSubscriptionWhereInput
  ) => CompletionRegisteredSubscriptionPayloadSubscription;
  course: (
    where?: CourseSubscriptionWhereInput
  ) => CourseSubscriptionPayloadSubscription;
  courseAlias: (
    where?: CourseAliasSubscriptionWhereInput
  ) => CourseAliasSubscriptionPayloadSubscription;
  service: (
    where?: ServiceSubscriptionWhereInput
  ) => ServiceSubscriptionPayloadSubscription;
  user: (
    where?: UserSubscriptionWhereInput
  ) => UserSubscriptionPayloadSubscription;
  userCourseProgress: (
    where?: UserCourseProgressSubscriptionWhereInput
  ) => UserCourseProgressSubscriptionPayloadSubscription;
  userCourseServiceProgress: (
    where?: UserCourseServiceProgressSubscriptionWhereInput
  ) => UserCourseServiceProgressSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type CompletionOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "created_at_ASC"
  | "created_at_DESC"
  | "updated_at_ASC"
  | "updated_at_DESC"
  | "user_upstream_id_ASC"
  | "user_upstream_id_DESC"
  | "email_ASC"
  | "email_DESC"
  | "student_number_ASC"
  | "student_number_DESC"
  | "completion_language_ASC"
  | "completion_language_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type CompletionRegisteredOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "created_at_ASC"
  | "created_at_DESC"
  | "updated_at_ASC"
  | "updated_at_DESC"
  | "real_student_number_ASC"
  | "real_student_number_DESC"
  | "organisation_ASC"
  | "organisation_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type CourseAliasOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "created_at_ASC"
  | "created_at_DESC"
  | "updated_at_ASC"
  | "updated_at_DESC"
  | "course_code_ASC"
  | "course_code_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type CourseOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "created_at_ASC"
  | "created_at_DESC"
  | "updated_at_ASC"
  | "updated_at_DESC"
  | "name_ASC"
  | "name_DESC"
  | "slug_ASC"
  | "slug_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ServiceOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "created_at_ASC"
  | "created_at_DESC"
  | "updated_at_ASC"
  | "updated_at_DESC"
  | "url_ASC"
  | "url_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type UserOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "upstream_id_ASC"
  | "upstream_id_DESC"
  | "created_at_ASC"
  | "created_at_DESC"
  | "updated_at_ASC"
  | "updated_at_DESC"
  | "first_name_ASC"
  | "first_name_DESC"
  | "last_name_ASC"
  | "last_name_DESC"
  | "username_ASC"
  | "username_DESC"
  | "email_ASC"
  | "email_DESC"
  | "administrator_ASC"
  | "administrator_DESC"
  | "student_number_ASC"
  | "student_number_DESC"
  | "real_student_number_ASC"
  | "real_student_number_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type UserCourseProgressOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "progress_ASC"
  | "progress_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type UserCourseServiceProgressOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "progress_ASC"
  | "progress_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export type CompletionWhereUniqueInput = AtLeastOne<{
  id: UUID;
}>;

export interface CompletionWhereInput {
  id?: UUID;
  id_not?: UUID;
  id_in?: UUID[] | UUID;
  id_not_in?: UUID[] | UUID;
  id_lt?: UUID;
  id_lte?: UUID;
  id_gt?: UUID;
  id_gte?: UUID;
  id_contains?: UUID;
  id_not_contains?: UUID;
  id_starts_with?: UUID;
  id_not_starts_with?: UUID;
  id_ends_with?: UUID;
  id_not_ends_with?: UUID;
  created_at?: DateTimeInput;
  created_at_not?: DateTimeInput;
  created_at_in?: DateTimeInput[] | DateTimeInput;
  created_at_not_in?: DateTimeInput[] | DateTimeInput;
  created_at_lt?: DateTimeInput;
  created_at_lte?: DateTimeInput;
  created_at_gt?: DateTimeInput;
  created_at_gte?: DateTimeInput;
  updated_at?: DateTimeInput;
  updated_at_not?: DateTimeInput;
  updated_at_in?: DateTimeInput[] | DateTimeInput;
  updated_at_not_in?: DateTimeInput[] | DateTimeInput;
  updated_at_lt?: DateTimeInput;
  updated_at_lte?: DateTimeInput;
  updated_at_gt?: DateTimeInput;
  updated_at_gte?: DateTimeInput;
  user_upstream_id?: Int;
  user_upstream_id_not?: Int;
  user_upstream_id_in?: Int[] | Int;
  user_upstream_id_not_in?: Int[] | Int;
  user_upstream_id_lt?: Int;
  user_upstream_id_lte?: Int;
  user_upstream_id_gt?: Int;
  user_upstream_id_gte?: Int;
  email?: String;
  email_not?: String;
  email_in?: String[] | String;
  email_not_in?: String[] | String;
  email_lt?: String;
  email_lte?: String;
  email_gt?: String;
  email_gte?: String;
  email_contains?: String;
  email_not_contains?: String;
  email_starts_with?: String;
  email_not_starts_with?: String;
  email_ends_with?: String;
  email_not_ends_with?: String;
  student_number?: String;
  student_number_not?: String;
  student_number_in?: String[] | String;
  student_number_not_in?: String[] | String;
  student_number_lt?: String;
  student_number_lte?: String;
  student_number_gt?: String;
  student_number_gte?: String;
  student_number_contains?: String;
  student_number_not_contains?: String;
  student_number_starts_with?: String;
  student_number_not_starts_with?: String;
  student_number_ends_with?: String;
  student_number_not_ends_with?: String;
  user?: UserWhereInput;
  course?: CourseWhereInput;
  completion_language?: String;
  completion_language_not?: String;
  completion_language_in?: String[] | String;
  completion_language_not_in?: String[] | String;
  completion_language_lt?: String;
  completion_language_lte?: String;
  completion_language_gt?: String;
  completion_language_gte?: String;
  completion_language_contains?: String;
  completion_language_not_contains?: String;
  completion_language_starts_with?: String;
  completion_language_not_starts_with?: String;
  completion_language_ends_with?: String;
  completion_language_not_ends_with?: String;
  AND?: CompletionWhereInput[] | CompletionWhereInput;
  OR?: CompletionWhereInput[] | CompletionWhereInput;
  NOT?: CompletionWhereInput[] | CompletionWhereInput;
}

export interface UserWhereInput {
  id?: UUID;
  id_not?: UUID;
  id_in?: UUID[] | UUID;
  id_not_in?: UUID[] | UUID;
  id_lt?: UUID;
  id_lte?: UUID;
  id_gt?: UUID;
  id_gte?: UUID;
  id_contains?: UUID;
  id_not_contains?: UUID;
  id_starts_with?: UUID;
  id_not_starts_with?: UUID;
  id_ends_with?: UUID;
  id_not_ends_with?: UUID;
  upstream_id?: Int;
  upstream_id_not?: Int;
  upstream_id_in?: Int[] | Int;
  upstream_id_not_in?: Int[] | Int;
  upstream_id_lt?: Int;
  upstream_id_lte?: Int;
  upstream_id_gt?: Int;
  upstream_id_gte?: Int;
  created_at?: DateTimeInput;
  created_at_not?: DateTimeInput;
  created_at_in?: DateTimeInput[] | DateTimeInput;
  created_at_not_in?: DateTimeInput[] | DateTimeInput;
  created_at_lt?: DateTimeInput;
  created_at_lte?: DateTimeInput;
  created_at_gt?: DateTimeInput;
  created_at_gte?: DateTimeInput;
  updated_at?: DateTimeInput;
  updated_at_not?: DateTimeInput;
  updated_at_in?: DateTimeInput[] | DateTimeInput;
  updated_at_not_in?: DateTimeInput[] | DateTimeInput;
  updated_at_lt?: DateTimeInput;
  updated_at_lte?: DateTimeInput;
  updated_at_gt?: DateTimeInput;
  updated_at_gte?: DateTimeInput;
  first_name?: String;
  first_name_not?: String;
  first_name_in?: String[] | String;
  first_name_not_in?: String[] | String;
  first_name_lt?: String;
  first_name_lte?: String;
  first_name_gt?: String;
  first_name_gte?: String;
  first_name_contains?: String;
  first_name_not_contains?: String;
  first_name_starts_with?: String;
  first_name_not_starts_with?: String;
  first_name_ends_with?: String;
  first_name_not_ends_with?: String;
  last_name?: String;
  last_name_not?: String;
  last_name_in?: String[] | String;
  last_name_not_in?: String[] | String;
  last_name_lt?: String;
  last_name_lte?: String;
  last_name_gt?: String;
  last_name_gte?: String;
  last_name_contains?: String;
  last_name_not_contains?: String;
  last_name_starts_with?: String;
  last_name_not_starts_with?: String;
  last_name_ends_with?: String;
  last_name_not_ends_with?: String;
  username?: String;
  username_not?: String;
  username_in?: String[] | String;
  username_not_in?: String[] | String;
  username_lt?: String;
  username_lte?: String;
  username_gt?: String;
  username_gte?: String;
  username_contains?: String;
  username_not_contains?: String;
  username_starts_with?: String;
  username_not_starts_with?: String;
  username_ends_with?: String;
  username_not_ends_with?: String;
  email?: String;
  email_not?: String;
  email_in?: String[] | String;
  email_not_in?: String[] | String;
  email_lt?: String;
  email_lte?: String;
  email_gt?: String;
  email_gte?: String;
  email_contains?: String;
  email_not_contains?: String;
  email_starts_with?: String;
  email_not_starts_with?: String;
  email_ends_with?: String;
  email_not_ends_with?: String;
  administrator?: Boolean;
  administrator_not?: Boolean;
  student_number?: String;
  student_number_not?: String;
  student_number_in?: String[] | String;
  student_number_not_in?: String[] | String;
  student_number_lt?: String;
  student_number_lte?: String;
  student_number_gt?: String;
  student_number_gte?: String;
  student_number_contains?: String;
  student_number_not_contains?: String;
  student_number_starts_with?: String;
  student_number_not_starts_with?: String;
  student_number_ends_with?: String;
  student_number_not_ends_with?: String;
  real_student_number?: String;
  real_student_number_not?: String;
  real_student_number_in?: String[] | String;
  real_student_number_not_in?: String[] | String;
  real_student_number_lt?: String;
  real_student_number_lte?: String;
  real_student_number_gt?: String;
  real_student_number_gte?: String;
  real_student_number_contains?: String;
  real_student_number_not_contains?: String;
  real_student_number_starts_with?: String;
  real_student_number_not_starts_with?: String;
  real_student_number_ends_with?: String;
  real_student_number_not_ends_with?: String;
  completions_every?: CompletionWhereInput;
  completions_some?: CompletionWhereInput;
  completions_none?: CompletionWhereInput;
  registered_completions_every?: CompletionRegisteredWhereInput;
  registered_completions_some?: CompletionRegisteredWhereInput;
  registered_completions_none?: CompletionRegisteredWhereInput;
  AND?: UserWhereInput[] | UserWhereInput;
  OR?: UserWhereInput[] | UserWhereInput;
  NOT?: UserWhereInput[] | UserWhereInput;
}

export interface CompletionRegisteredWhereInput {
  id?: UUID;
  id_not?: UUID;
  id_in?: UUID[] | UUID;
  id_not_in?: UUID[] | UUID;
  id_lt?: UUID;
  id_lte?: UUID;
  id_gt?: UUID;
  id_gte?: UUID;
  id_contains?: UUID;
  id_not_contains?: UUID;
  id_starts_with?: UUID;
  id_not_starts_with?: UUID;
  id_ends_with?: UUID;
  id_not_ends_with?: UUID;
  created_at?: DateTimeInput;
  created_at_not?: DateTimeInput;
  created_at_in?: DateTimeInput[] | DateTimeInput;
  created_at_not_in?: DateTimeInput[] | DateTimeInput;
  created_at_lt?: DateTimeInput;
  created_at_lte?: DateTimeInput;
  created_at_gt?: DateTimeInput;
  created_at_gte?: DateTimeInput;
  updated_at?: DateTimeInput;
  updated_at_not?: DateTimeInput;
  updated_at_in?: DateTimeInput[] | DateTimeInput;
  updated_at_not_in?: DateTimeInput[] | DateTimeInput;
  updated_at_lt?: DateTimeInput;
  updated_at_lte?: DateTimeInput;
  updated_at_gt?: DateTimeInput;
  updated_at_gte?: DateTimeInput;
  user?: UserWhereInput;
  course?: CourseWhereInput;
  real_student_number?: String;
  real_student_number_not?: String;
  real_student_number_in?: String[] | String;
  real_student_number_not_in?: String[] | String;
  real_student_number_lt?: String;
  real_student_number_lte?: String;
  real_student_number_gt?: String;
  real_student_number_gte?: String;
  real_student_number_contains?: String;
  real_student_number_not_contains?: String;
  real_student_number_starts_with?: String;
  real_student_number_not_starts_with?: String;
  real_student_number_ends_with?: String;
  real_student_number_not_ends_with?: String;
  organisation?: String;
  organisation_not?: String;
  organisation_in?: String[] | String;
  organisation_not_in?: String[] | String;
  organisation_lt?: String;
  organisation_lte?: String;
  organisation_gt?: String;
  organisation_gte?: String;
  organisation_contains?: String;
  organisation_not_contains?: String;
  organisation_starts_with?: String;
  organisation_not_starts_with?: String;
  organisation_ends_with?: String;
  organisation_not_ends_with?: String;
  completion?: CompletionWhereInput;
  AND?: CompletionRegisteredWhereInput[] | CompletionRegisteredWhereInput;
  OR?: CompletionRegisteredWhereInput[] | CompletionRegisteredWhereInput;
  NOT?: CompletionRegisteredWhereInput[] | CompletionRegisteredWhereInput;
}

export interface CourseWhereInput {
  id?: UUID;
  id_not?: UUID;
  id_in?: UUID[] | UUID;
  id_not_in?: UUID[] | UUID;
  id_lt?: UUID;
  id_lte?: UUID;
  id_gt?: UUID;
  id_gte?: UUID;
  id_contains?: UUID;
  id_not_contains?: UUID;
  id_starts_with?: UUID;
  id_not_starts_with?: UUID;
  id_ends_with?: UUID;
  id_not_ends_with?: UUID;
  created_at?: DateTimeInput;
  created_at_not?: DateTimeInput;
  created_at_in?: DateTimeInput[] | DateTimeInput;
  created_at_not_in?: DateTimeInput[] | DateTimeInput;
  created_at_lt?: DateTimeInput;
  created_at_lte?: DateTimeInput;
  created_at_gt?: DateTimeInput;
  created_at_gte?: DateTimeInput;
  updated_at?: DateTimeInput;
  updated_at_not?: DateTimeInput;
  updated_at_in?: DateTimeInput[] | DateTimeInput;
  updated_at_not_in?: DateTimeInput[] | DateTimeInput;
  updated_at_lt?: DateTimeInput;
  updated_at_lte?: DateTimeInput;
  updated_at_gt?: DateTimeInput;
  updated_at_gte?: DateTimeInput;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  slug?: String;
  slug_not?: String;
  slug_in?: String[] | String;
  slug_not_in?: String[] | String;
  slug_lt?: String;
  slug_lte?: String;
  slug_gt?: String;
  slug_gte?: String;
  slug_contains?: String;
  slug_not_contains?: String;
  slug_starts_with?: String;
  slug_not_starts_with?: String;
  slug_ends_with?: String;
  slug_not_ends_with?: String;
  open_university_courses_every?: CourseAliasWhereInput;
  open_university_courses_some?: CourseAliasWhereInput;
  open_university_courses_none?: CourseAliasWhereInput;
  AND?: CourseWhereInput[] | CourseWhereInput;
  OR?: CourseWhereInput[] | CourseWhereInput;
  NOT?: CourseWhereInput[] | CourseWhereInput;
}

export interface CourseAliasWhereInput {
  id?: UUID;
  id_not?: UUID;
  id_in?: UUID[] | UUID;
  id_not_in?: UUID[] | UUID;
  id_lt?: UUID;
  id_lte?: UUID;
  id_gt?: UUID;
  id_gte?: UUID;
  id_contains?: UUID;
  id_not_contains?: UUID;
  id_starts_with?: UUID;
  id_not_starts_with?: UUID;
  id_ends_with?: UUID;
  id_not_ends_with?: UUID;
  created_at?: DateTimeInput;
  created_at_not?: DateTimeInput;
  created_at_in?: DateTimeInput[] | DateTimeInput;
  created_at_not_in?: DateTimeInput[] | DateTimeInput;
  created_at_lt?: DateTimeInput;
  created_at_lte?: DateTimeInput;
  created_at_gt?: DateTimeInput;
  created_at_gte?: DateTimeInput;
  updated_at?: DateTimeInput;
  updated_at_not?: DateTimeInput;
  updated_at_in?: DateTimeInput[] | DateTimeInput;
  updated_at_not_in?: DateTimeInput[] | DateTimeInput;
  updated_at_lt?: DateTimeInput;
  updated_at_lte?: DateTimeInput;
  updated_at_gt?: DateTimeInput;
  updated_at_gte?: DateTimeInput;
  course_code?: String;
  course_code_not?: String;
  course_code_in?: String[] | String;
  course_code_not_in?: String[] | String;
  course_code_lt?: String;
  course_code_lte?: String;
  course_code_gt?: String;
  course_code_gte?: String;
  course_code_contains?: String;
  course_code_not_contains?: String;
  course_code_starts_with?: String;
  course_code_not_starts_with?: String;
  course_code_ends_with?: String;
  course_code_not_ends_with?: String;
  course?: CourseWhereInput;
  AND?: CourseAliasWhereInput[] | CourseAliasWhereInput;
  OR?: CourseAliasWhereInput[] | CourseAliasWhereInput;
  NOT?: CourseAliasWhereInput[] | CourseAliasWhereInput;
}

export type CompletionRegisteredWhereUniqueInput = AtLeastOne<{
  id: UUID;
}>;

export type CourseWhereUniqueInput = AtLeastOne<{
  id: UUID;
  slug?: String;
}>;

export type CourseAliasWhereUniqueInput = AtLeastOne<{
  id: UUID;
  course_code?: String;
}>;

export type ServiceWhereUniqueInput = AtLeastOne<{
  id: UUID;
}>;

export interface ServiceWhereInput {
  id?: UUID;
  id_not?: UUID;
  id_in?: UUID[] | UUID;
  id_not_in?: UUID[] | UUID;
  id_lt?: UUID;
  id_lte?: UUID;
  id_gt?: UUID;
  id_gte?: UUID;
  id_contains?: UUID;
  id_not_contains?: UUID;
  id_starts_with?: UUID;
  id_not_starts_with?: UUID;
  id_ends_with?: UUID;
  id_not_ends_with?: UUID;
  created_at?: DateTimeInput;
  created_at_not?: DateTimeInput;
  created_at_in?: DateTimeInput[] | DateTimeInput;
  created_at_not_in?: DateTimeInput[] | DateTimeInput;
  created_at_lt?: DateTimeInput;
  created_at_lte?: DateTimeInput;
  created_at_gt?: DateTimeInput;
  created_at_gte?: DateTimeInput;
  updated_at?: DateTimeInput;
  updated_at_not?: DateTimeInput;
  updated_at_in?: DateTimeInput[] | DateTimeInput;
  updated_at_not_in?: DateTimeInput[] | DateTimeInput;
  updated_at_lt?: DateTimeInput;
  updated_at_lte?: DateTimeInput;
  updated_at_gt?: DateTimeInput;
  updated_at_gte?: DateTimeInput;
  url?: String;
  url_not?: String;
  url_in?: String[] | String;
  url_not_in?: String[] | String;
  url_lt?: String;
  url_lte?: String;
  url_gt?: String;
  url_gte?: String;
  url_contains?: String;
  url_not_contains?: String;
  url_starts_with?: String;
  url_not_starts_with?: String;
  url_ends_with?: String;
  url_not_ends_with?: String;
  AND?: ServiceWhereInput[] | ServiceWhereInput;
  OR?: ServiceWhereInput[] | ServiceWhereInput;
  NOT?: ServiceWhereInput[] | ServiceWhereInput;
}

export type UserWhereUniqueInput = AtLeastOne<{
  id: UUID;
  upstream_id?: Int;
  username?: String;
}>;

export type UserCourseProgressWhereUniqueInput = AtLeastOne<{
  id: UUID;
}>;

export interface UserCourseProgressWhereInput {
  id?: UUID;
  id_not?: UUID;
  id_in?: UUID[] | UUID;
  id_not_in?: UUID[] | UUID;
  id_lt?: UUID;
  id_lte?: UUID;
  id_gt?: UUID;
  id_gte?: UUID;
  id_contains?: UUID;
  id_not_contains?: UUID;
  id_starts_with?: UUID;
  id_not_starts_with?: UUID;
  id_ends_with?: UUID;
  id_not_ends_with?: UUID;
  user?: UserWhereInput;
  course?: CourseWhereInput;
  AND?: UserCourseProgressWhereInput[] | UserCourseProgressWhereInput;
  OR?: UserCourseProgressWhereInput[] | UserCourseProgressWhereInput;
  NOT?: UserCourseProgressWhereInput[] | UserCourseProgressWhereInput;
}

export type UserCourseServiceProgressWhereUniqueInput = AtLeastOne<{
  id: UUID;
}>;

export interface UserCourseServiceProgressWhereInput {
  id?: UUID;
  id_not?: UUID;
  id_in?: UUID[] | UUID;
  id_not_in?: UUID[] | UUID;
  id_lt?: UUID;
  id_lte?: UUID;
  id_gt?: UUID;
  id_gte?: UUID;
  id_contains?: UUID;
  id_not_contains?: UUID;
  id_starts_with?: UUID;
  id_not_starts_with?: UUID;
  id_ends_with?: UUID;
  id_not_ends_with?: UUID;
  user?: UserWhereInput;
  course?: CourseWhereInput;
  service?: ServiceWhereInput;
  AND?:
    | UserCourseServiceProgressWhereInput[]
    | UserCourseServiceProgressWhereInput;
  OR?:
    | UserCourseServiceProgressWhereInput[]
    | UserCourseServiceProgressWhereInput;
  NOT?:
    | UserCourseServiceProgressWhereInput[]
    | UserCourseServiceProgressWhereInput;
}

export interface CompletionCreateInput {
  id?: UUID;
  created_at?: DateTimeInput;
  updated_at?: DateTimeInput;
  user_upstream_id?: Int;
  email: String;
  student_number?: String;
  user: UserCreateOneWithoutCompletionsInput;
  course: CourseCreateOneInput;
  completion_language?: String;
}

export interface UserCreateOneWithoutCompletionsInput {
  create?: UserCreateWithoutCompletionsInput;
  connect?: UserWhereUniqueInput;
}

export interface UserCreateWithoutCompletionsInput {
  id?: UUID;
  upstream_id: Int;
  created_at?: DateTimeInput;
  updated_at?: DateTimeInput;
  first_name?: String;
  last_name?: String;
  username: String;
  email: String;
  administrator: Boolean;
  student_number?: String;
  real_student_number?: String;
  registered_completions?: CompletionRegisteredCreateManyWithoutUserInput;
}

export interface CompletionRegisteredCreateManyWithoutUserInput {
  create?:
    | CompletionRegisteredCreateWithoutUserInput[]
    | CompletionRegisteredCreateWithoutUserInput;
  connect?:
    | CompletionRegisteredWhereUniqueInput[]
    | CompletionRegisteredWhereUniqueInput;
}

export interface CompletionRegisteredCreateWithoutUserInput {
  id?: UUID;
  created_at?: DateTimeInput;
  updated_at?: DateTimeInput;
  course: CourseCreateOneInput;
  real_student_number: String;
  organisation: String;
  completion: CompletionCreateOneInput;
}

export interface CourseCreateOneInput {
  create?: CourseCreateInput;
  connect?: CourseWhereUniqueInput;
}

export interface CourseCreateInput {
  id?: UUID;
  created_at?: DateTimeInput;
  updated_at?: DateTimeInput;
  name: String;
  slug: String;
  open_university_courses?: CourseAliasCreateManyWithoutCourseInput;
}

export interface CourseAliasCreateManyWithoutCourseInput {
  create?:
    | CourseAliasCreateWithoutCourseInput[]
    | CourseAliasCreateWithoutCourseInput;
  connect?: CourseAliasWhereUniqueInput[] | CourseAliasWhereUniqueInput;
}

export interface CourseAliasCreateWithoutCourseInput {
  id?: UUID;
  created_at?: DateTimeInput;
  updated_at?: DateTimeInput;
  course_code: String;
}

export interface CompletionCreateOneInput {
  create?: CompletionCreateInput;
  connect?: CompletionWhereUniqueInput;
}

export interface CompletionUpdateInput {
  created_at?: DateTimeInput;
  updated_at?: DateTimeInput;
  user_upstream_id?: Int;
  email?: String;
  student_number?: String;
  user?: UserUpdateOneRequiredWithoutCompletionsInput;
  course?: CourseUpdateOneRequiredInput;
  completion_language?: String;
}

export interface UserUpdateOneRequiredWithoutCompletionsInput {
  create?: UserCreateWithoutCompletionsInput;
  update?: UserUpdateWithoutCompletionsDataInput;
  upsert?: UserUpsertWithoutCompletionsInput;
  connect?: UserWhereUniqueInput;
}

export interface UserUpdateWithoutCompletionsDataInput {
  upstream_id?: Int;
  created_at?: DateTimeInput;
  updated_at?: DateTimeInput;
  first_name?: String;
  last_name?: String;
  username?: String;
  email?: String;
  administrator?: Boolean;
  student_number?: String;
  real_student_number?: String;
  registered_completions?: CompletionRegisteredUpdateManyWithoutUserInput;
}

export interface CompletionRegisteredUpdateManyWithoutUserInput {
  create?:
    | CompletionRegisteredCreateWithoutUserInput[]
    | CompletionRegisteredCreateWithoutUserInput;
  delete?:
    | CompletionRegisteredWhereUniqueInput[]
    | CompletionRegisteredWhereUniqueInput;
  connect?:
    | CompletionRegisteredWhereUniqueInput[]
    | CompletionRegisteredWhereUniqueInput;
  set?:
    | CompletionRegisteredWhereUniqueInput[]
    | CompletionRegisteredWhereUniqueInput;
  disconnect?:
    | CompletionRegisteredWhereUniqueInput[]
    | CompletionRegisteredWhereUniqueInput;
  update?:
    | CompletionRegisteredUpdateWithWhereUniqueWithoutUserInput[]
    | CompletionRegisteredUpdateWithWhereUniqueWithoutUserInput;
  upsert?:
    | CompletionRegisteredUpsertWithWhereUniqueWithoutUserInput[]
    | CompletionRegisteredUpsertWithWhereUniqueWithoutUserInput;
  deleteMany?:
    | CompletionRegisteredScalarWhereInput[]
    | CompletionRegisteredScalarWhereInput;
  updateMany?:
    | CompletionRegisteredUpdateManyWithWhereNestedInput[]
    | CompletionRegisteredUpdateManyWithWhereNestedInput;
}

export interface CompletionRegisteredUpdateWithWhereUniqueWithoutUserInput {
  where: CompletionRegisteredWhereUniqueInput;
  data: CompletionRegisteredUpdateWithoutUserDataInput;
}

export interface CompletionRegisteredUpdateWithoutUserDataInput {
  created_at?: DateTimeInput;
  updated_at?: DateTimeInput;
  course?: CourseUpdateOneRequiredInput;
  real_student_number?: String;
  organisation?: String;
  completion?: CompletionUpdateOneRequiredInput;
}

export interface CourseUpdateOneRequiredInput {
  create?: CourseCreateInput;
  update?: CourseUpdateDataInput;
  upsert?: CourseUpsertNestedInput;
  connect?: CourseWhereUniqueInput;
}

export interface CourseUpdateDataInput {
  created_at?: DateTimeInput;
  updated_at?: DateTimeInput;
  name?: String;
  slug?: String;
  open_university_courses?: CourseAliasUpdateManyWithoutCourseInput;
}

export interface CourseAliasUpdateManyWithoutCourseInput {
  create?:
    | CourseAliasCreateWithoutCourseInput[]
    | CourseAliasCreateWithoutCourseInput;
  delete?: CourseAliasWhereUniqueInput[] | CourseAliasWhereUniqueInput;
  connect?: CourseAliasWhereUniqueInput[] | CourseAliasWhereUniqueInput;
  set?: CourseAliasWhereUniqueInput[] | CourseAliasWhereUniqueInput;
  disconnect?: CourseAliasWhereUniqueInput[] | CourseAliasWhereUniqueInput;
  update?:
    | CourseAliasUpdateWithWhereUniqueWithoutCourseInput[]
    | CourseAliasUpdateWithWhereUniqueWithoutCourseInput;
  upsert?:
    | CourseAliasUpsertWithWhereUniqueWithoutCourseInput[]
    | CourseAliasUpsertWithWhereUniqueWithoutCourseInput;
  deleteMany?: CourseAliasScalarWhereInput[] | CourseAliasScalarWhereInput;
  updateMany?:
    | CourseAliasUpdateManyWithWhereNestedInput[]
    | CourseAliasUpdateManyWithWhereNestedInput;
}

export interface CourseAliasUpdateWithWhereUniqueWithoutCourseInput {
  where: CourseAliasWhereUniqueInput;
  data: CourseAliasUpdateWithoutCourseDataInput;
}

export interface CourseAliasUpdateWithoutCourseDataInput {
  created_at?: DateTimeInput;
  updated_at?: DateTimeInput;
  course_code?: String;
}

export interface CourseAliasUpsertWithWhereUniqueWithoutCourseInput {
  where: CourseAliasWhereUniqueInput;
  update: CourseAliasUpdateWithoutCourseDataInput;
  create: CourseAliasCreateWithoutCourseInput;
}

export interface CourseAliasScalarWhereInput {
  id?: UUID;
  id_not?: UUID;
  id_in?: UUID[] | UUID;
  id_not_in?: UUID[] | UUID;
  id_lt?: UUID;
  id_lte?: UUID;
  id_gt?: UUID;
  id_gte?: UUID;
  id_contains?: UUID;
  id_not_contains?: UUID;
  id_starts_with?: UUID;
  id_not_starts_with?: UUID;
  id_ends_with?: UUID;
  id_not_ends_with?: UUID;
  created_at?: DateTimeInput;
  created_at_not?: DateTimeInput;
  created_at_in?: DateTimeInput[] | DateTimeInput;
  created_at_not_in?: DateTimeInput[] | DateTimeInput;
  created_at_lt?: DateTimeInput;
  created_at_lte?: DateTimeInput;
  created_at_gt?: DateTimeInput;
  created_at_gte?: DateTimeInput;
  updated_at?: DateTimeInput;
  updated_at_not?: DateTimeInput;
  updated_at_in?: DateTimeInput[] | DateTimeInput;
  updated_at_not_in?: DateTimeInput[] | DateTimeInput;
  updated_at_lt?: DateTimeInput;
  updated_at_lte?: DateTimeInput;
  updated_at_gt?: DateTimeInput;
  updated_at_gte?: DateTimeInput;
  course_code?: String;
  course_code_not?: String;
  course_code_in?: String[] | String;
  course_code_not_in?: String[] | String;
  course_code_lt?: String;
  course_code_lte?: String;
  course_code_gt?: String;
  course_code_gte?: String;
  course_code_contains?: String;
  course_code_not_contains?: String;
  course_code_starts_with?: String;
  course_code_not_starts_with?: String;
  course_code_ends_with?: String;
  course_code_not_ends_with?: String;
  AND?: CourseAliasScalarWhereInput[] | CourseAliasScalarWhereInput;
  OR?: CourseAliasScalarWhereInput[] | CourseAliasScalarWhereInput;
  NOT?: CourseAliasScalarWhereInput[] | CourseAliasScalarWhereInput;
}

export interface CourseAliasUpdateManyWithWhereNestedInput {
  where: CourseAliasScalarWhereInput;
  data: CourseAliasUpdateManyDataInput;
}

export interface CourseAliasUpdateManyDataInput {
  created_at?: DateTimeInput;
  updated_at?: DateTimeInput;
  course_code?: String;
}

export interface CourseUpsertNestedInput {
  update: CourseUpdateDataInput;
  create: CourseCreateInput;
}

export interface CompletionUpdateOneRequiredInput {
  create?: CompletionCreateInput;
  update?: CompletionUpdateDataInput;
  upsert?: CompletionUpsertNestedInput;
  connect?: CompletionWhereUniqueInput;
}

export interface CompletionUpdateDataInput {
  created_at?: DateTimeInput;
  updated_at?: DateTimeInput;
  user_upstream_id?: Int;
  email?: String;
  student_number?: String;
  user?: UserUpdateOneRequiredWithoutCompletionsInput;
  course?: CourseUpdateOneRequiredInput;
  completion_language?: String;
}

export interface CompletionUpsertNestedInput {
  update: CompletionUpdateDataInput;
  create: CompletionCreateInput;
}

export interface CompletionRegisteredUpsertWithWhereUniqueWithoutUserInput {
  where: CompletionRegisteredWhereUniqueInput;
  update: CompletionRegisteredUpdateWithoutUserDataInput;
  create: CompletionRegisteredCreateWithoutUserInput;
}

export interface CompletionRegisteredScalarWhereInput {
  id?: UUID;
  id_not?: UUID;
  id_in?: UUID[] | UUID;
  id_not_in?: UUID[] | UUID;
  id_lt?: UUID;
  id_lte?: UUID;
  id_gt?: UUID;
  id_gte?: UUID;
  id_contains?: UUID;
  id_not_contains?: UUID;
  id_starts_with?: UUID;
  id_not_starts_with?: UUID;
  id_ends_with?: UUID;
  id_not_ends_with?: UUID;
  created_at?: DateTimeInput;
  created_at_not?: DateTimeInput;
  created_at_in?: DateTimeInput[] | DateTimeInput;
  created_at_not_in?: DateTimeInput[] | DateTimeInput;
  created_at_lt?: DateTimeInput;
  created_at_lte?: DateTimeInput;
  created_at_gt?: DateTimeInput;
  created_at_gte?: DateTimeInput;
  updated_at?: DateTimeInput;
  updated_at_not?: DateTimeInput;
  updated_at_in?: DateTimeInput[] | DateTimeInput;
  updated_at_not_in?: DateTimeInput[] | DateTimeInput;
  updated_at_lt?: DateTimeInput;
  updated_at_lte?: DateTimeInput;
  updated_at_gt?: DateTimeInput;
  updated_at_gte?: DateTimeInput;
  real_student_number?: String;
  real_student_number_not?: String;
  real_student_number_in?: String[] | String;
  real_student_number_not_in?: String[] | String;
  real_student_number_lt?: String;
  real_student_number_lte?: String;
  real_student_number_gt?: String;
  real_student_number_gte?: String;
  real_student_number_contains?: String;
  real_student_number_not_contains?: String;
  real_student_number_starts_with?: String;
  real_student_number_not_starts_with?: String;
  real_student_number_ends_with?: String;
  real_student_number_not_ends_with?: String;
  organisation?: String;
  organisation_not?: String;
  organisation_in?: String[] | String;
  organisation_not_in?: String[] | String;
  organisation_lt?: String;
  organisation_lte?: String;
  organisation_gt?: String;
  organisation_gte?: String;
  organisation_contains?: String;
  organisation_not_contains?: String;
  organisation_starts_with?: String;
  organisation_not_starts_with?: String;
  organisation_ends_with?: String;
  organisation_not_ends_with?: String;
  AND?:
    | CompletionRegisteredScalarWhereInput[]
    | CompletionRegisteredScalarWhereInput;
  OR?:
    | CompletionRegisteredScalarWhereInput[]
    | CompletionRegisteredScalarWhereInput;
  NOT?:
    | CompletionRegisteredScalarWhereInput[]
    | CompletionRegisteredScalarWhereInput;
}

export interface CompletionRegisteredUpdateManyWithWhereNestedInput {
  where: CompletionRegisteredScalarWhereInput;
  data: CompletionRegisteredUpdateManyDataInput;
}

export interface CompletionRegisteredUpdateManyDataInput {
  created_at?: DateTimeInput;
  updated_at?: DateTimeInput;
  real_student_number?: String;
  organisation?: String;
}

export interface UserUpsertWithoutCompletionsInput {
  update: UserUpdateWithoutCompletionsDataInput;
  create: UserCreateWithoutCompletionsInput;
}

export interface CompletionUpdateManyMutationInput {
  created_at?: DateTimeInput;
  updated_at?: DateTimeInput;
  user_upstream_id?: Int;
  email?: String;
  student_number?: String;
  completion_language?: String;
}

export interface CompletionRegisteredCreateInput {
  id?: UUID;
  created_at?: DateTimeInput;
  updated_at?: DateTimeInput;
  user: UserCreateOneWithoutRegistered_completionsInput;
  course: CourseCreateOneInput;
  real_student_number: String;
  organisation: String;
  completion: CompletionCreateOneInput;
}

export interface UserCreateOneWithoutRegistered_completionsInput {
  create?: UserCreateWithoutRegistered_completionsInput;
  connect?: UserWhereUniqueInput;
}

export interface UserCreateWithoutRegistered_completionsInput {
  id?: UUID;
  upstream_id: Int;
  created_at?: DateTimeInput;
  updated_at?: DateTimeInput;
  first_name?: String;
  last_name?: String;
  username: String;
  email: String;
  administrator: Boolean;
  student_number?: String;
  real_student_number?: String;
  completions?: CompletionCreateManyWithoutUserInput;
}

export interface CompletionCreateManyWithoutUserInput {
  create?:
    | CompletionCreateWithoutUserInput[]
    | CompletionCreateWithoutUserInput;
  connect?: CompletionWhereUniqueInput[] | CompletionWhereUniqueInput;
}

export interface CompletionCreateWithoutUserInput {
  id?: UUID;
  created_at?: DateTimeInput;
  updated_at?: DateTimeInput;
  user_upstream_id?: Int;
  email: String;
  student_number?: String;
  course: CourseCreateOneInput;
  completion_language?: String;
}

export interface CompletionRegisteredUpdateInput {
  created_at?: DateTimeInput;
  updated_at?: DateTimeInput;
  user?: UserUpdateOneRequiredWithoutRegistered_completionsInput;
  course?: CourseUpdateOneRequiredInput;
  real_student_number?: String;
  organisation?: String;
  completion?: CompletionUpdateOneRequiredInput;
}

export interface UserUpdateOneRequiredWithoutRegistered_completionsInput {
  create?: UserCreateWithoutRegistered_completionsInput;
  update?: UserUpdateWithoutRegistered_completionsDataInput;
  upsert?: UserUpsertWithoutRegistered_completionsInput;
  connect?: UserWhereUniqueInput;
}

export interface UserUpdateWithoutRegistered_completionsDataInput {
  upstream_id?: Int;
  created_at?: DateTimeInput;
  updated_at?: DateTimeInput;
  first_name?: String;
  last_name?: String;
  username?: String;
  email?: String;
  administrator?: Boolean;
  student_number?: String;
  real_student_number?: String;
  completions?: CompletionUpdateManyWithoutUserInput;
}

export interface CompletionUpdateManyWithoutUserInput {
  create?:
    | CompletionCreateWithoutUserInput[]
    | CompletionCreateWithoutUserInput;
  delete?: CompletionWhereUniqueInput[] | CompletionWhereUniqueInput;
  connect?: CompletionWhereUniqueInput[] | CompletionWhereUniqueInput;
  set?: CompletionWhereUniqueInput[] | CompletionWhereUniqueInput;
  disconnect?: CompletionWhereUniqueInput[] | CompletionWhereUniqueInput;
  update?:
    | CompletionUpdateWithWhereUniqueWithoutUserInput[]
    | CompletionUpdateWithWhereUniqueWithoutUserInput;
  upsert?:
    | CompletionUpsertWithWhereUniqueWithoutUserInput[]
    | CompletionUpsertWithWhereUniqueWithoutUserInput;
  deleteMany?: CompletionScalarWhereInput[] | CompletionScalarWhereInput;
  updateMany?:
    | CompletionUpdateManyWithWhereNestedInput[]
    | CompletionUpdateManyWithWhereNestedInput;
}

export interface CompletionUpdateWithWhereUniqueWithoutUserInput {
  where: CompletionWhereUniqueInput;
  data: CompletionUpdateWithoutUserDataInput;
}

export interface CompletionUpdateWithoutUserDataInput {
  created_at?: DateTimeInput;
  updated_at?: DateTimeInput;
  user_upstream_id?: Int;
  email?: String;
  student_number?: String;
  course?: CourseUpdateOneRequiredInput;
  completion_language?: String;
}

export interface CompletionUpsertWithWhereUniqueWithoutUserInput {
  where: CompletionWhereUniqueInput;
  update: CompletionUpdateWithoutUserDataInput;
  create: CompletionCreateWithoutUserInput;
}

export interface CompletionScalarWhereInput {
  id?: UUID;
  id_not?: UUID;
  id_in?: UUID[] | UUID;
  id_not_in?: UUID[] | UUID;
  id_lt?: UUID;
  id_lte?: UUID;
  id_gt?: UUID;
  id_gte?: UUID;
  id_contains?: UUID;
  id_not_contains?: UUID;
  id_starts_with?: UUID;
  id_not_starts_with?: UUID;
  id_ends_with?: UUID;
  id_not_ends_with?: UUID;
  created_at?: DateTimeInput;
  created_at_not?: DateTimeInput;
  created_at_in?: DateTimeInput[] | DateTimeInput;
  created_at_not_in?: DateTimeInput[] | DateTimeInput;
  created_at_lt?: DateTimeInput;
  created_at_lte?: DateTimeInput;
  created_at_gt?: DateTimeInput;
  created_at_gte?: DateTimeInput;
  updated_at?: DateTimeInput;
  updated_at_not?: DateTimeInput;
  updated_at_in?: DateTimeInput[] | DateTimeInput;
  updated_at_not_in?: DateTimeInput[] | DateTimeInput;
  updated_at_lt?: DateTimeInput;
  updated_at_lte?: DateTimeInput;
  updated_at_gt?: DateTimeInput;
  updated_at_gte?: DateTimeInput;
  user_upstream_id?: Int;
  user_upstream_id_not?: Int;
  user_upstream_id_in?: Int[] | Int;
  user_upstream_id_not_in?: Int[] | Int;
  user_upstream_id_lt?: Int;
  user_upstream_id_lte?: Int;
  user_upstream_id_gt?: Int;
  user_upstream_id_gte?: Int;
  email?: String;
  email_not?: String;
  email_in?: String[] | String;
  email_not_in?: String[] | String;
  email_lt?: String;
  email_lte?: String;
  email_gt?: String;
  email_gte?: String;
  email_contains?: String;
  email_not_contains?: String;
  email_starts_with?: String;
  email_not_starts_with?: String;
  email_ends_with?: String;
  email_not_ends_with?: String;
  student_number?: String;
  student_number_not?: String;
  student_number_in?: String[] | String;
  student_number_not_in?: String[] | String;
  student_number_lt?: String;
  student_number_lte?: String;
  student_number_gt?: String;
  student_number_gte?: String;
  student_number_contains?: String;
  student_number_not_contains?: String;
  student_number_starts_with?: String;
  student_number_not_starts_with?: String;
  student_number_ends_with?: String;
  student_number_not_ends_with?: String;
  completion_language?: String;
  completion_language_not?: String;
  completion_language_in?: String[] | String;
  completion_language_not_in?: String[] | String;
  completion_language_lt?: String;
  completion_language_lte?: String;
  completion_language_gt?: String;
  completion_language_gte?: String;
  completion_language_contains?: String;
  completion_language_not_contains?: String;
  completion_language_starts_with?: String;
  completion_language_not_starts_with?: String;
  completion_language_ends_with?: String;
  completion_language_not_ends_with?: String;
  AND?: CompletionScalarWhereInput[] | CompletionScalarWhereInput;
  OR?: CompletionScalarWhereInput[] | CompletionScalarWhereInput;
  NOT?: CompletionScalarWhereInput[] | CompletionScalarWhereInput;
}

export interface CompletionUpdateManyWithWhereNestedInput {
  where: CompletionScalarWhereInput;
  data: CompletionUpdateManyDataInput;
}

export interface CompletionUpdateManyDataInput {
  created_at?: DateTimeInput;
  updated_at?: DateTimeInput;
  user_upstream_id?: Int;
  email?: String;
  student_number?: String;
  completion_language?: String;
}

export interface UserUpsertWithoutRegistered_completionsInput {
  update: UserUpdateWithoutRegistered_completionsDataInput;
  create: UserCreateWithoutRegistered_completionsInput;
}

export interface CompletionRegisteredUpdateManyMutationInput {
  created_at?: DateTimeInput;
  updated_at?: DateTimeInput;
  real_student_number?: String;
  organisation?: String;
}

export interface CourseUpdateInput {
  created_at?: DateTimeInput;
  updated_at?: DateTimeInput;
  name?: String;
  slug?: String;
  open_university_courses?: CourseAliasUpdateManyWithoutCourseInput;
}

export interface CourseUpdateManyMutationInput {
  created_at?: DateTimeInput;
  updated_at?: DateTimeInput;
  name?: String;
  slug?: String;
}

export interface CourseAliasCreateInput {
  id?: UUID;
  created_at?: DateTimeInput;
  updated_at?: DateTimeInput;
  course_code: String;
  course: CourseCreateOneWithoutOpen_university_coursesInput;
}

export interface CourseCreateOneWithoutOpen_university_coursesInput {
  create?: CourseCreateWithoutOpen_university_coursesInput;
  connect?: CourseWhereUniqueInput;
}

export interface CourseCreateWithoutOpen_university_coursesInput {
  id?: UUID;
  created_at?: DateTimeInput;
  updated_at?: DateTimeInput;
  name: String;
  slug: String;
}

export interface CourseAliasUpdateInput {
  created_at?: DateTimeInput;
  updated_at?: DateTimeInput;
  course_code?: String;
  course?: CourseUpdateOneRequiredWithoutOpen_university_coursesInput;
}

export interface CourseUpdateOneRequiredWithoutOpen_university_coursesInput {
  create?: CourseCreateWithoutOpen_university_coursesInput;
  update?: CourseUpdateWithoutOpen_university_coursesDataInput;
  upsert?: CourseUpsertWithoutOpen_university_coursesInput;
  connect?: CourseWhereUniqueInput;
}

export interface CourseUpdateWithoutOpen_university_coursesDataInput {
  created_at?: DateTimeInput;
  updated_at?: DateTimeInput;
  name?: String;
  slug?: String;
}

export interface CourseUpsertWithoutOpen_university_coursesInput {
  update: CourseUpdateWithoutOpen_university_coursesDataInput;
  create: CourseCreateWithoutOpen_university_coursesInput;
}

export interface CourseAliasUpdateManyMutationInput {
  created_at?: DateTimeInput;
  updated_at?: DateTimeInput;
  course_code?: String;
}

export interface ServiceCreateInput {
  id?: UUID;
  created_at?: DateTimeInput;
  updated_at?: DateTimeInput;
  url: String;
}

export interface ServiceUpdateInput {
  created_at?: DateTimeInput;
  updated_at?: DateTimeInput;
  url?: String;
}

export interface ServiceUpdateManyMutationInput {
  created_at?: DateTimeInput;
  updated_at?: DateTimeInput;
  url?: String;
}

export interface UserCreateInput {
  id?: UUID;
  upstream_id: Int;
  created_at?: DateTimeInput;
  updated_at?: DateTimeInput;
  first_name?: String;
  last_name?: String;
  username: String;
  email: String;
  administrator: Boolean;
  student_number?: String;
  real_student_number?: String;
  completions?: CompletionCreateManyWithoutUserInput;
  registered_completions?: CompletionRegisteredCreateManyWithoutUserInput;
}

export interface UserUpdateInput {
  upstream_id?: Int;
  created_at?: DateTimeInput;
  updated_at?: DateTimeInput;
  first_name?: String;
  last_name?: String;
  username?: String;
  email?: String;
  administrator?: Boolean;
  student_number?: String;
  real_student_number?: String;
  completions?: CompletionUpdateManyWithoutUserInput;
  registered_completions?: CompletionRegisteredUpdateManyWithoutUserInput;
}

export interface UserUpdateManyMutationInput {
  upstream_id?: Int;
  created_at?: DateTimeInput;
  updated_at?: DateTimeInput;
  first_name?: String;
  last_name?: String;
  username?: String;
  email?: String;
  administrator?: Boolean;
  student_number?: String;
  real_student_number?: String;
}

export interface UserCourseProgressCreateInput {
  id?: UUID;
  user: UserCreateOneInput;
  course: CourseCreateOneInput;
  progress: Json;
}

export interface UserCreateOneInput {
  create?: UserCreateInput;
  connect?: UserWhereUniqueInput;
}

export interface UserCourseProgressUpdateInput {
  user?: UserUpdateOneRequiredInput;
  course?: CourseUpdateOneRequiredInput;
  progress?: Json;
}

export interface UserUpdateOneRequiredInput {
  create?: UserCreateInput;
  update?: UserUpdateDataInput;
  upsert?: UserUpsertNestedInput;
  connect?: UserWhereUniqueInput;
}

export interface UserUpdateDataInput {
  upstream_id?: Int;
  created_at?: DateTimeInput;
  updated_at?: DateTimeInput;
  first_name?: String;
  last_name?: String;
  username?: String;
  email?: String;
  administrator?: Boolean;
  student_number?: String;
  real_student_number?: String;
  completions?: CompletionUpdateManyWithoutUserInput;
  registered_completions?: CompletionRegisteredUpdateManyWithoutUserInput;
}

export interface UserUpsertNestedInput {
  update: UserUpdateDataInput;
  create: UserCreateInput;
}

export interface UserCourseProgressUpdateManyMutationInput {
  progress?: Json;
}

export interface UserCourseServiceProgressCreateInput {
  id?: UUID;
  user: UserCreateOneInput;
  course: CourseCreateOneInput;
  service: ServiceCreateOneInput;
  progress: Json;
}

export interface ServiceCreateOneInput {
  create?: ServiceCreateInput;
  connect?: ServiceWhereUniqueInput;
}

export interface UserCourseServiceProgressUpdateInput {
  user?: UserUpdateOneRequiredInput;
  course?: CourseUpdateOneRequiredInput;
  service?: ServiceUpdateOneRequiredInput;
  progress?: Json;
}

export interface ServiceUpdateOneRequiredInput {
  create?: ServiceCreateInput;
  update?: ServiceUpdateDataInput;
  upsert?: ServiceUpsertNestedInput;
  connect?: ServiceWhereUniqueInput;
}

export interface ServiceUpdateDataInput {
  created_at?: DateTimeInput;
  updated_at?: DateTimeInput;
  url?: String;
}

export interface ServiceUpsertNestedInput {
  update: ServiceUpdateDataInput;
  create: ServiceCreateInput;
}

export interface UserCourseServiceProgressUpdateManyMutationInput {
  progress?: Json;
}

export interface CompletionSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: CompletionWhereInput;
  AND?: CompletionSubscriptionWhereInput[] | CompletionSubscriptionWhereInput;
  OR?: CompletionSubscriptionWhereInput[] | CompletionSubscriptionWhereInput;
  NOT?: CompletionSubscriptionWhereInput[] | CompletionSubscriptionWhereInput;
}

export interface CompletionRegisteredSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: CompletionRegisteredWhereInput;
  AND?:
    | CompletionRegisteredSubscriptionWhereInput[]
    | CompletionRegisteredSubscriptionWhereInput;
  OR?:
    | CompletionRegisteredSubscriptionWhereInput[]
    | CompletionRegisteredSubscriptionWhereInput;
  NOT?:
    | CompletionRegisteredSubscriptionWhereInput[]
    | CompletionRegisteredSubscriptionWhereInput;
}

export interface CourseSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: CourseWhereInput;
  AND?: CourseSubscriptionWhereInput[] | CourseSubscriptionWhereInput;
  OR?: CourseSubscriptionWhereInput[] | CourseSubscriptionWhereInput;
  NOT?: CourseSubscriptionWhereInput[] | CourseSubscriptionWhereInput;
}

export interface CourseAliasSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: CourseAliasWhereInput;
  AND?: CourseAliasSubscriptionWhereInput[] | CourseAliasSubscriptionWhereInput;
  OR?: CourseAliasSubscriptionWhereInput[] | CourseAliasSubscriptionWhereInput;
  NOT?: CourseAliasSubscriptionWhereInput[] | CourseAliasSubscriptionWhereInput;
}

export interface ServiceSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ServiceWhereInput;
  AND?: ServiceSubscriptionWhereInput[] | ServiceSubscriptionWhereInput;
  OR?: ServiceSubscriptionWhereInput[] | ServiceSubscriptionWhereInput;
  NOT?: ServiceSubscriptionWhereInput[] | ServiceSubscriptionWhereInput;
}

export interface UserSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: UserWhereInput;
  AND?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
  OR?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
  NOT?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
}

export interface UserCourseProgressSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: UserCourseProgressWhereInput;
  AND?:
    | UserCourseProgressSubscriptionWhereInput[]
    | UserCourseProgressSubscriptionWhereInput;
  OR?:
    | UserCourseProgressSubscriptionWhereInput[]
    | UserCourseProgressSubscriptionWhereInput;
  NOT?:
    | UserCourseProgressSubscriptionWhereInput[]
    | UserCourseProgressSubscriptionWhereInput;
}

export interface UserCourseServiceProgressSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: UserCourseServiceProgressWhereInput;
  AND?:
    | UserCourseServiceProgressSubscriptionWhereInput[]
    | UserCourseServiceProgressSubscriptionWhereInput;
  OR?:
    | UserCourseServiceProgressSubscriptionWhereInput[]
    | UserCourseServiceProgressSubscriptionWhereInput;
  NOT?:
    | UserCourseServiceProgressSubscriptionWhereInput[]
    | UserCourseServiceProgressSubscriptionWhereInput;
}

export interface NodeNode {
  id: ID_Output;
}

export interface Completion {
  id: UUID;
  created_at?: DateTimeOutput;
  updated_at?: DateTimeOutput;
  user_upstream_id?: Int;
  email: String;
  student_number?: String;
  completion_language?: String;
}

export interface CompletionPromise extends Promise<Completion>, Fragmentable {
  id: () => Promise<UUID>;
  created_at: () => Promise<DateTimeOutput>;
  updated_at: () => Promise<DateTimeOutput>;
  user_upstream_id: () => Promise<Int>;
  email: () => Promise<String>;
  student_number: () => Promise<String>;
  user: <T = UserPromise>() => T;
  course: <T = CoursePromise>() => T;
  completion_language: () => Promise<String>;
}

export interface CompletionSubscription
  extends Promise<AsyncIterator<Completion>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<UUID>>;
  created_at: () => Promise<AsyncIterator<DateTimeOutput>>;
  updated_at: () => Promise<AsyncIterator<DateTimeOutput>>;
  user_upstream_id: () => Promise<AsyncIterator<Int>>;
  email: () => Promise<AsyncIterator<String>>;
  student_number: () => Promise<AsyncIterator<String>>;
  user: <T = UserSubscription>() => T;
  course: <T = CourseSubscription>() => T;
  completion_language: () => Promise<AsyncIterator<String>>;
}

export interface User {
  id: UUID;
  upstream_id: Int;
  created_at?: DateTimeOutput;
  updated_at?: DateTimeOutput;
  first_name?: String;
  last_name?: String;
  username: String;
  email: String;
  administrator: Boolean;
  student_number?: String;
  real_student_number?: String;
}

export interface UserPromise extends Promise<User>, Fragmentable {
  id: () => Promise<UUID>;
  upstream_id: () => Promise<Int>;
  created_at: () => Promise<DateTimeOutput>;
  updated_at: () => Promise<DateTimeOutput>;
  first_name: () => Promise<String>;
  last_name: () => Promise<String>;
  username: () => Promise<String>;
  email: () => Promise<String>;
  administrator: () => Promise<Boolean>;
  student_number: () => Promise<String>;
  real_student_number: () => Promise<String>;
  completions: <T = FragmentableArray<Completion>>(
    args?: {
      where?: CompletionWhereInput;
      orderBy?: CompletionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  registered_completions: <T = FragmentableArray<CompletionRegistered>>(
    args?: {
      where?: CompletionRegisteredWhereInput;
      orderBy?: CompletionRegisteredOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface UserSubscription
  extends Promise<AsyncIterator<User>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<UUID>>;
  upstream_id: () => Promise<AsyncIterator<Int>>;
  created_at: () => Promise<AsyncIterator<DateTimeOutput>>;
  updated_at: () => Promise<AsyncIterator<DateTimeOutput>>;
  first_name: () => Promise<AsyncIterator<String>>;
  last_name: () => Promise<AsyncIterator<String>>;
  username: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  administrator: () => Promise<AsyncIterator<Boolean>>;
  student_number: () => Promise<AsyncIterator<String>>;
  real_student_number: () => Promise<AsyncIterator<String>>;
  completions: <T = Promise<AsyncIterator<CompletionSubscription>>>(
    args?: {
      where?: CompletionWhereInput;
      orderBy?: CompletionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  registered_completions: <
    T = Promise<AsyncIterator<CompletionRegisteredSubscription>>
  >(
    args?: {
      where?: CompletionRegisteredWhereInput;
      orderBy?: CompletionRegisteredOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface CompletionRegistered {
  id: UUID;
  created_at?: DateTimeOutput;
  updated_at?: DateTimeOutput;
  real_student_number: String;
  organisation: String;
}

export interface CompletionRegisteredPromise
  extends Promise<CompletionRegistered>,
    Fragmentable {
  id: () => Promise<UUID>;
  created_at: () => Promise<DateTimeOutput>;
  updated_at: () => Promise<DateTimeOutput>;
  user: <T = UserPromise>() => T;
  course: <T = CoursePromise>() => T;
  real_student_number: () => Promise<String>;
  organisation: () => Promise<String>;
  completion: <T = CompletionPromise>() => T;
}

export interface CompletionRegisteredSubscription
  extends Promise<AsyncIterator<CompletionRegistered>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<UUID>>;
  created_at: () => Promise<AsyncIterator<DateTimeOutput>>;
  updated_at: () => Promise<AsyncIterator<DateTimeOutput>>;
  user: <T = UserSubscription>() => T;
  course: <T = CourseSubscription>() => T;
  real_student_number: () => Promise<AsyncIterator<String>>;
  organisation: () => Promise<AsyncIterator<String>>;
  completion: <T = CompletionSubscription>() => T;
}

export interface Course {
  id: UUID;
  created_at?: DateTimeOutput;
  updated_at?: DateTimeOutput;
  name: String;
  slug: String;
}

export interface CoursePromise extends Promise<Course>, Fragmentable {
  id: () => Promise<UUID>;
  created_at: () => Promise<DateTimeOutput>;
  updated_at: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
  slug: () => Promise<String>;
  open_university_courses: <T = FragmentableArray<CourseAlias>>(
    args?: {
      where?: CourseAliasWhereInput;
      orderBy?: CourseAliasOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface CourseSubscription
  extends Promise<AsyncIterator<Course>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<UUID>>;
  created_at: () => Promise<AsyncIterator<DateTimeOutput>>;
  updated_at: () => Promise<AsyncIterator<DateTimeOutput>>;
  name: () => Promise<AsyncIterator<String>>;
  slug: () => Promise<AsyncIterator<String>>;
  open_university_courses: <
    T = Promise<AsyncIterator<CourseAliasSubscription>>
  >(
    args?: {
      where?: CourseAliasWhereInput;
      orderBy?: CourseAliasOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface CourseAlias {
  id: UUID;
  created_at?: DateTimeOutput;
  updated_at?: DateTimeOutput;
  course_code: String;
}

export interface CourseAliasPromise extends Promise<CourseAlias>, Fragmentable {
  id: () => Promise<UUID>;
  created_at: () => Promise<DateTimeOutput>;
  updated_at: () => Promise<DateTimeOutput>;
  course_code: () => Promise<String>;
  course: <T = CoursePromise>() => T;
}

export interface CourseAliasSubscription
  extends Promise<AsyncIterator<CourseAlias>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<UUID>>;
  created_at: () => Promise<AsyncIterator<DateTimeOutput>>;
  updated_at: () => Promise<AsyncIterator<DateTimeOutput>>;
  course_code: () => Promise<AsyncIterator<String>>;
  course: <T = CourseSubscription>() => T;
}

export interface CompletionConnection {
  pageInfo: PageInfo;
  edges: CompletionEdge[];
}

export interface CompletionConnectionPromise
  extends Promise<CompletionConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CompletionEdge>>() => T;
  aggregate: <T = AggregateCompletionPromise>() => T;
}

export interface CompletionConnectionSubscription
  extends Promise<AsyncIterator<CompletionConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CompletionEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCompletionSubscription>() => T;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface CompletionEdge {
  node: Completion;
  cursor: String;
}

export interface CompletionEdgePromise
  extends Promise<CompletionEdge>,
    Fragmentable {
  node: <T = CompletionPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CompletionEdgeSubscription
  extends Promise<AsyncIterator<CompletionEdge>>,
    Fragmentable {
  node: <T = CompletionSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateCompletion {
  count: Int;
}

export interface AggregateCompletionPromise
  extends Promise<AggregateCompletion>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCompletionSubscription
  extends Promise<AsyncIterator<AggregateCompletion>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CompletionRegisteredConnection {
  pageInfo: PageInfo;
  edges: CompletionRegisteredEdge[];
}

export interface CompletionRegisteredConnectionPromise
  extends Promise<CompletionRegisteredConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CompletionRegisteredEdge>>() => T;
  aggregate: <T = AggregateCompletionRegisteredPromise>() => T;
}

export interface CompletionRegisteredConnectionSubscription
  extends Promise<AsyncIterator<CompletionRegisteredConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<CompletionRegisteredEdgeSubscription>>
  >() => T;
  aggregate: <T = AggregateCompletionRegisteredSubscription>() => T;
}

export interface CompletionRegisteredEdge {
  node: CompletionRegistered;
  cursor: String;
}

export interface CompletionRegisteredEdgePromise
  extends Promise<CompletionRegisteredEdge>,
    Fragmentable {
  node: <T = CompletionRegisteredPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CompletionRegisteredEdgeSubscription
  extends Promise<AsyncIterator<CompletionRegisteredEdge>>,
    Fragmentable {
  node: <T = CompletionRegisteredSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateCompletionRegistered {
  count: Int;
}

export interface AggregateCompletionRegisteredPromise
  extends Promise<AggregateCompletionRegistered>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCompletionRegisteredSubscription
  extends Promise<AsyncIterator<AggregateCompletionRegistered>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CourseConnection {
  pageInfo: PageInfo;
  edges: CourseEdge[];
}

export interface CourseConnectionPromise
  extends Promise<CourseConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CourseEdge>>() => T;
  aggregate: <T = AggregateCoursePromise>() => T;
}

export interface CourseConnectionSubscription
  extends Promise<AsyncIterator<CourseConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CourseEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCourseSubscription>() => T;
}

export interface CourseEdge {
  node: Course;
  cursor: String;
}

export interface CourseEdgePromise extends Promise<CourseEdge>, Fragmentable {
  node: <T = CoursePromise>() => T;
  cursor: () => Promise<String>;
}

export interface CourseEdgeSubscription
  extends Promise<AsyncIterator<CourseEdge>>,
    Fragmentable {
  node: <T = CourseSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateCourse {
  count: Int;
}

export interface AggregateCoursePromise
  extends Promise<AggregateCourse>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCourseSubscription
  extends Promise<AsyncIterator<AggregateCourse>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CourseAliasConnection {
  pageInfo: PageInfo;
  edges: CourseAliasEdge[];
}

export interface CourseAliasConnectionPromise
  extends Promise<CourseAliasConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CourseAliasEdge>>() => T;
  aggregate: <T = AggregateCourseAliasPromise>() => T;
}

export interface CourseAliasConnectionSubscription
  extends Promise<AsyncIterator<CourseAliasConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CourseAliasEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCourseAliasSubscription>() => T;
}

export interface CourseAliasEdge {
  node: CourseAlias;
  cursor: String;
}

export interface CourseAliasEdgePromise
  extends Promise<CourseAliasEdge>,
    Fragmentable {
  node: <T = CourseAliasPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CourseAliasEdgeSubscription
  extends Promise<AsyncIterator<CourseAliasEdge>>,
    Fragmentable {
  node: <T = CourseAliasSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateCourseAlias {
  count: Int;
}

export interface AggregateCourseAliasPromise
  extends Promise<AggregateCourseAlias>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCourseAliasSubscription
  extends Promise<AsyncIterator<AggregateCourseAlias>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Service {
  id: UUID;
  created_at?: DateTimeOutput;
  updated_at?: DateTimeOutput;
  url: String;
}

export interface ServicePromise extends Promise<Service>, Fragmentable {
  id: () => Promise<UUID>;
  created_at: () => Promise<DateTimeOutput>;
  updated_at: () => Promise<DateTimeOutput>;
  url: () => Promise<String>;
}

export interface ServiceSubscription
  extends Promise<AsyncIterator<Service>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<UUID>>;
  created_at: () => Promise<AsyncIterator<DateTimeOutput>>;
  updated_at: () => Promise<AsyncIterator<DateTimeOutput>>;
  url: () => Promise<AsyncIterator<String>>;
}

export interface ServiceConnection {
  pageInfo: PageInfo;
  edges: ServiceEdge[];
}

export interface ServiceConnectionPromise
  extends Promise<ServiceConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ServiceEdge>>() => T;
  aggregate: <T = AggregateServicePromise>() => T;
}

export interface ServiceConnectionSubscription
  extends Promise<AsyncIterator<ServiceConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ServiceEdgeSubscription>>>() => T;
  aggregate: <T = AggregateServiceSubscription>() => T;
}

export interface ServiceEdge {
  node: Service;
  cursor: String;
}

export interface ServiceEdgePromise extends Promise<ServiceEdge>, Fragmentable {
  node: <T = ServicePromise>() => T;
  cursor: () => Promise<String>;
}

export interface ServiceEdgeSubscription
  extends Promise<AsyncIterator<ServiceEdge>>,
    Fragmentable {
  node: <T = ServiceSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateService {
  count: Int;
}

export interface AggregateServicePromise
  extends Promise<AggregateService>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateServiceSubscription
  extends Promise<AsyncIterator<AggregateService>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface UserConnection {
  pageInfo: PageInfo;
  edges: UserEdge[];
}

export interface UserConnectionPromise
  extends Promise<UserConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserEdge>>() => T;
  aggregate: <T = AggregateUserPromise>() => T;
}

export interface UserConnectionSubscription
  extends Promise<AsyncIterator<UserConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserSubscription>() => T;
}

export interface UserEdge {
  node: User;
  cursor: String;
}

export interface UserEdgePromise extends Promise<UserEdge>, Fragmentable {
  node: <T = UserPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserEdgeSubscription
  extends Promise<AsyncIterator<UserEdge>>,
    Fragmentable {
  node: <T = UserSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateUser {
  count: Int;
}

export interface AggregateUserPromise
  extends Promise<AggregateUser>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserSubscription
  extends Promise<AsyncIterator<AggregateUser>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface UserCourseProgress {
  id: UUID;
  progress: Json;
}

export interface UserCourseProgressPromise
  extends Promise<UserCourseProgress>,
    Fragmentable {
  id: () => Promise<UUID>;
  user: <T = UserPromise>() => T;
  course: <T = CoursePromise>() => T;
  progress: () => Promise<Json>;
}

export interface UserCourseProgressSubscription
  extends Promise<AsyncIterator<UserCourseProgress>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<UUID>>;
  user: <T = UserSubscription>() => T;
  course: <T = CourseSubscription>() => T;
  progress: () => Promise<AsyncIterator<Json>>;
}

export interface UserCourseProgressConnection {
  pageInfo: PageInfo;
  edges: UserCourseProgressEdge[];
}

export interface UserCourseProgressConnectionPromise
  extends Promise<UserCourseProgressConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserCourseProgressEdge>>() => T;
  aggregate: <T = AggregateUserCourseProgressPromise>() => T;
}

export interface UserCourseProgressConnectionSubscription
  extends Promise<AsyncIterator<UserCourseProgressConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<UserCourseProgressEdgeSubscription>>
  >() => T;
  aggregate: <T = AggregateUserCourseProgressSubscription>() => T;
}

export interface UserCourseProgressEdge {
  node: UserCourseProgress;
  cursor: String;
}

export interface UserCourseProgressEdgePromise
  extends Promise<UserCourseProgressEdge>,
    Fragmentable {
  node: <T = UserCourseProgressPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserCourseProgressEdgeSubscription
  extends Promise<AsyncIterator<UserCourseProgressEdge>>,
    Fragmentable {
  node: <T = UserCourseProgressSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateUserCourseProgress {
  count: Int;
}

export interface AggregateUserCourseProgressPromise
  extends Promise<AggregateUserCourseProgress>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserCourseProgressSubscription
  extends Promise<AsyncIterator<AggregateUserCourseProgress>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface UserCourseServiceProgress {
  id: UUID;
  progress: Json;
}

export interface UserCourseServiceProgressPromise
  extends Promise<UserCourseServiceProgress>,
    Fragmentable {
  id: () => Promise<UUID>;
  user: <T = UserPromise>() => T;
  course: <T = CoursePromise>() => T;
  service: <T = ServicePromise>() => T;
  progress: () => Promise<Json>;
}

export interface UserCourseServiceProgressSubscription
  extends Promise<AsyncIterator<UserCourseServiceProgress>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<UUID>>;
  user: <T = UserSubscription>() => T;
  course: <T = CourseSubscription>() => T;
  service: <T = ServiceSubscription>() => T;
  progress: () => Promise<AsyncIterator<Json>>;
}

export interface UserCourseServiceProgressConnection {
  pageInfo: PageInfo;
  edges: UserCourseServiceProgressEdge[];
}

export interface UserCourseServiceProgressConnectionPromise
  extends Promise<UserCourseServiceProgressConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserCourseServiceProgressEdge>>() => T;
  aggregate: <T = AggregateUserCourseServiceProgressPromise>() => T;
}

export interface UserCourseServiceProgressConnectionSubscription
  extends Promise<AsyncIterator<UserCourseServiceProgressConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<UserCourseServiceProgressEdgeSubscription>>
  >() => T;
  aggregate: <T = AggregateUserCourseServiceProgressSubscription>() => T;
}

export interface UserCourseServiceProgressEdge {
  node: UserCourseServiceProgress;
  cursor: String;
}

export interface UserCourseServiceProgressEdgePromise
  extends Promise<UserCourseServiceProgressEdge>,
    Fragmentable {
  node: <T = UserCourseServiceProgressPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserCourseServiceProgressEdgeSubscription
  extends Promise<AsyncIterator<UserCourseServiceProgressEdge>>,
    Fragmentable {
  node: <T = UserCourseServiceProgressSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateUserCourseServiceProgress {
  count: Int;
}

export interface AggregateUserCourseServiceProgressPromise
  extends Promise<AggregateUserCourseServiceProgress>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserCourseServiceProgressSubscription
  extends Promise<AsyncIterator<AggregateUserCourseServiceProgress>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface CompletionSubscriptionPayload {
  mutation: MutationType;
  node: Completion;
  updatedFields: String[];
  previousValues: CompletionPreviousValues;
}

export interface CompletionSubscriptionPayloadPromise
  extends Promise<CompletionSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CompletionPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CompletionPreviousValuesPromise>() => T;
}

export interface CompletionSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CompletionSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CompletionSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CompletionPreviousValuesSubscription>() => T;
}

export interface CompletionPreviousValues {
  id: UUID;
  created_at?: DateTimeOutput;
  updated_at?: DateTimeOutput;
  user_upstream_id?: Int;
  email: String;
  student_number?: String;
  completion_language?: String;
}

export interface CompletionPreviousValuesPromise
  extends Promise<CompletionPreviousValues>,
    Fragmentable {
  id: () => Promise<UUID>;
  created_at: () => Promise<DateTimeOutput>;
  updated_at: () => Promise<DateTimeOutput>;
  user_upstream_id: () => Promise<Int>;
  email: () => Promise<String>;
  student_number: () => Promise<String>;
  completion_language: () => Promise<String>;
}

export interface CompletionPreviousValuesSubscription
  extends Promise<AsyncIterator<CompletionPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<UUID>>;
  created_at: () => Promise<AsyncIterator<DateTimeOutput>>;
  updated_at: () => Promise<AsyncIterator<DateTimeOutput>>;
  user_upstream_id: () => Promise<AsyncIterator<Int>>;
  email: () => Promise<AsyncIterator<String>>;
  student_number: () => Promise<AsyncIterator<String>>;
  completion_language: () => Promise<AsyncIterator<String>>;
}

export interface CompletionRegisteredSubscriptionPayload {
  mutation: MutationType;
  node: CompletionRegistered;
  updatedFields: String[];
  previousValues: CompletionRegisteredPreviousValues;
}

export interface CompletionRegisteredSubscriptionPayloadPromise
  extends Promise<CompletionRegisteredSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CompletionRegisteredPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CompletionRegisteredPreviousValuesPromise>() => T;
}

export interface CompletionRegisteredSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CompletionRegisteredSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CompletionRegisteredSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CompletionRegisteredPreviousValuesSubscription>() => T;
}

export interface CompletionRegisteredPreviousValues {
  id: UUID;
  created_at?: DateTimeOutput;
  updated_at?: DateTimeOutput;
  real_student_number: String;
  organisation: String;
}

export interface CompletionRegisteredPreviousValuesPromise
  extends Promise<CompletionRegisteredPreviousValues>,
    Fragmentable {
  id: () => Promise<UUID>;
  created_at: () => Promise<DateTimeOutput>;
  updated_at: () => Promise<DateTimeOutput>;
  real_student_number: () => Promise<String>;
  organisation: () => Promise<String>;
}

export interface CompletionRegisteredPreviousValuesSubscription
  extends Promise<AsyncIterator<CompletionRegisteredPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<UUID>>;
  created_at: () => Promise<AsyncIterator<DateTimeOutput>>;
  updated_at: () => Promise<AsyncIterator<DateTimeOutput>>;
  real_student_number: () => Promise<AsyncIterator<String>>;
  organisation: () => Promise<AsyncIterator<String>>;
}

export interface CourseSubscriptionPayload {
  mutation: MutationType;
  node: Course;
  updatedFields: String[];
  previousValues: CoursePreviousValues;
}

export interface CourseSubscriptionPayloadPromise
  extends Promise<CourseSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CoursePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CoursePreviousValuesPromise>() => T;
}

export interface CourseSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CourseSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CourseSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CoursePreviousValuesSubscription>() => T;
}

export interface CoursePreviousValues {
  id: UUID;
  created_at?: DateTimeOutput;
  updated_at?: DateTimeOutput;
  name: String;
  slug: String;
}

export interface CoursePreviousValuesPromise
  extends Promise<CoursePreviousValues>,
    Fragmentable {
  id: () => Promise<UUID>;
  created_at: () => Promise<DateTimeOutput>;
  updated_at: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
  slug: () => Promise<String>;
}

export interface CoursePreviousValuesSubscription
  extends Promise<AsyncIterator<CoursePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<UUID>>;
  created_at: () => Promise<AsyncIterator<DateTimeOutput>>;
  updated_at: () => Promise<AsyncIterator<DateTimeOutput>>;
  name: () => Promise<AsyncIterator<String>>;
  slug: () => Promise<AsyncIterator<String>>;
}

export interface CourseAliasSubscriptionPayload {
  mutation: MutationType;
  node: CourseAlias;
  updatedFields: String[];
  previousValues: CourseAliasPreviousValues;
}

export interface CourseAliasSubscriptionPayloadPromise
  extends Promise<CourseAliasSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CourseAliasPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CourseAliasPreviousValuesPromise>() => T;
}

export interface CourseAliasSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CourseAliasSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CourseAliasSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CourseAliasPreviousValuesSubscription>() => T;
}

export interface CourseAliasPreviousValues {
  id: UUID;
  created_at?: DateTimeOutput;
  updated_at?: DateTimeOutput;
  course_code: String;
}

export interface CourseAliasPreviousValuesPromise
  extends Promise<CourseAliasPreviousValues>,
    Fragmentable {
  id: () => Promise<UUID>;
  created_at: () => Promise<DateTimeOutput>;
  updated_at: () => Promise<DateTimeOutput>;
  course_code: () => Promise<String>;
}

export interface CourseAliasPreviousValuesSubscription
  extends Promise<AsyncIterator<CourseAliasPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<UUID>>;
  created_at: () => Promise<AsyncIterator<DateTimeOutput>>;
  updated_at: () => Promise<AsyncIterator<DateTimeOutput>>;
  course_code: () => Promise<AsyncIterator<String>>;
}

export interface ServiceSubscriptionPayload {
  mutation: MutationType;
  node: Service;
  updatedFields: String[];
  previousValues: ServicePreviousValues;
}

export interface ServiceSubscriptionPayloadPromise
  extends Promise<ServiceSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ServicePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ServicePreviousValuesPromise>() => T;
}

export interface ServiceSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ServiceSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ServiceSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ServicePreviousValuesSubscription>() => T;
}

export interface ServicePreviousValues {
  id: UUID;
  created_at?: DateTimeOutput;
  updated_at?: DateTimeOutput;
  url: String;
}

export interface ServicePreviousValuesPromise
  extends Promise<ServicePreviousValues>,
    Fragmentable {
  id: () => Promise<UUID>;
  created_at: () => Promise<DateTimeOutput>;
  updated_at: () => Promise<DateTimeOutput>;
  url: () => Promise<String>;
}

export interface ServicePreviousValuesSubscription
  extends Promise<AsyncIterator<ServicePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<UUID>>;
  created_at: () => Promise<AsyncIterator<DateTimeOutput>>;
  updated_at: () => Promise<AsyncIterator<DateTimeOutput>>;
  url: () => Promise<AsyncIterator<String>>;
}

export interface UserSubscriptionPayload {
  mutation: MutationType;
  node: User;
  updatedFields: String[];
  previousValues: UserPreviousValues;
}

export interface UserSubscriptionPayloadPromise
  extends Promise<UserSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserPreviousValuesPromise>() => T;
}

export interface UserSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserPreviousValuesSubscription>() => T;
}

export interface UserPreviousValues {
  id: UUID;
  upstream_id: Int;
  created_at?: DateTimeOutput;
  updated_at?: DateTimeOutput;
  first_name?: String;
  last_name?: String;
  username: String;
  email: String;
  administrator: Boolean;
  student_number?: String;
  real_student_number?: String;
}

export interface UserPreviousValuesPromise
  extends Promise<UserPreviousValues>,
    Fragmentable {
  id: () => Promise<UUID>;
  upstream_id: () => Promise<Int>;
  created_at: () => Promise<DateTimeOutput>;
  updated_at: () => Promise<DateTimeOutput>;
  first_name: () => Promise<String>;
  last_name: () => Promise<String>;
  username: () => Promise<String>;
  email: () => Promise<String>;
  administrator: () => Promise<Boolean>;
  student_number: () => Promise<String>;
  real_student_number: () => Promise<String>;
}

export interface UserPreviousValuesSubscription
  extends Promise<AsyncIterator<UserPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<UUID>>;
  upstream_id: () => Promise<AsyncIterator<Int>>;
  created_at: () => Promise<AsyncIterator<DateTimeOutput>>;
  updated_at: () => Promise<AsyncIterator<DateTimeOutput>>;
  first_name: () => Promise<AsyncIterator<String>>;
  last_name: () => Promise<AsyncIterator<String>>;
  username: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  administrator: () => Promise<AsyncIterator<Boolean>>;
  student_number: () => Promise<AsyncIterator<String>>;
  real_student_number: () => Promise<AsyncIterator<String>>;
}

export interface UserCourseProgressSubscriptionPayload {
  mutation: MutationType;
  node: UserCourseProgress;
  updatedFields: String[];
  previousValues: UserCourseProgressPreviousValues;
}

export interface UserCourseProgressSubscriptionPayloadPromise
  extends Promise<UserCourseProgressSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserCourseProgressPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserCourseProgressPreviousValuesPromise>() => T;
}

export interface UserCourseProgressSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserCourseProgressSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserCourseProgressSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserCourseProgressPreviousValuesSubscription>() => T;
}

export interface UserCourseProgressPreviousValues {
  id: UUID;
  progress: Json;
}

export interface UserCourseProgressPreviousValuesPromise
  extends Promise<UserCourseProgressPreviousValues>,
    Fragmentable {
  id: () => Promise<UUID>;
  progress: () => Promise<Json>;
}

export interface UserCourseProgressPreviousValuesSubscription
  extends Promise<AsyncIterator<UserCourseProgressPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<UUID>>;
  progress: () => Promise<AsyncIterator<Json>>;
}

export interface UserCourseServiceProgressSubscriptionPayload {
  mutation: MutationType;
  node: UserCourseServiceProgress;
  updatedFields: String[];
  previousValues: UserCourseServiceProgressPreviousValues;
}

export interface UserCourseServiceProgressSubscriptionPayloadPromise
  extends Promise<UserCourseServiceProgressSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserCourseServiceProgressPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserCourseServiceProgressPreviousValuesPromise>() => T;
}

export interface UserCourseServiceProgressSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserCourseServiceProgressSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserCourseServiceProgressSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <
    T = UserCourseServiceProgressPreviousValuesSubscription
  >() => T;
}

export interface UserCourseServiceProgressPreviousValues {
  id: UUID;
  progress: Json;
}

export interface UserCourseServiceProgressPreviousValuesPromise
  extends Promise<UserCourseServiceProgressPreviousValues>,
    Fragmentable {
  id: () => Promise<UUID>;
  progress: () => Promise<Json>;
}

export interface UserCourseServiceProgressPreviousValuesSubscription
  extends Promise<AsyncIterator<UserCourseServiceProgressPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<UUID>>;
  progress: () => Promise<AsyncIterator<Json>>;
}

export type UUID = string;

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1. 
*/
export type Int = number;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

export type Json = any;

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

export type Long = string;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "User",
    embedded: false
  },
  {
    name: "Course",
    embedded: false
  },
  {
    name: "CourseAlias",
    embedded: false
  },
  {
    name: "Completion",
    embedded: false
  },
  {
    name: "CompletionRegistered",
    embedded: false
  },
  {
    name: "Service",
    embedded: false
  },
  {
    name: "UserCourseProgress",
    embedded: false
  },
  {
    name: "UserCourseServiceProgress",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const Prisma = makePrismaClientClass<ClientConstructor<Prisma>>({
  typeDefs,
  models,
  endpoint: `http://localhost:4466`
});
export const prisma = new Prisma();
