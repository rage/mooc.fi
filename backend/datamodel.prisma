type User @db(name: "user") {
  id: UUID! @id
  "User's unique identifier from TMC"
  upstream_id: Int! @unique
  created_at: DateTime @createdAt
  updated_at: DateTime @updatedAt
  first_name: String
  last_name: String
  "TMC random generated username"
  username: String! @unique
  email: String!
  administrator: Boolean!
  student_number: String
  "Confirmed student number"
  real_student_number: String
  "User's completions"
  completions: [Completion!]! @relation(name: "CompletionToUser")
  "User's completions that have been reqistered for ECTS etc."
  registered_completions: [CompletionRegistered!]! @relation(name: "CompletionRegisteredToUser")
  created_organization: [Organization!]! @relation(name: "OrganizationToUser")
}

type Course @db(name: "course") {
  id: UUID! @id
  created_at: DateTime @createdAt
  updated_at: DateTime @updatedAt
  name: String!
  "identify course in other api querys"
  slug: String! @unique
  "aliases that can be used in this this api instead of slug "
  course_aliases: [CourseAlias!]! @relation(name: "CourseToCourseAlias")
  services: [Service] @relation(name: "CourseToService")
}

type CourseAlias  @db(name: "course_alias"){
  id: UUID! @id
  created_at: DateTime @createdAt
  updated_at: DateTime @updatedAt
  "The actual code/slug that is used in querys"
  course_code: String! @unique
  "Which course this code links to"
  course: Course! @relation(link: INLINE, name: "CourseToCourseAlias")
}

type Completion @db(name: "completion") {
  id: UUID! @id
  created_at: DateTime @createdAt
  updated_at: DateTime @updatedAt
  "User's unique identifier. Should be used to deduplicate registered completions, since all the other fields can change."
  user_upstream_id: Int
  email: String!
  student_number: String
  user: User!  @relation(link: INLINE, name: "CompletionToUser")
  course: Course! @relation(link: INLINE, name: "CompletionToCourse")
  completion_language: String
  "Where this completion has been registered, can have multiple locations."
  completions_registered: [CompletionRegistered!]! @relation(name: "CompletionRegisteredToCompletion") 
}

type CompletionRegistered @db(name: "completion_registered") {
  id: UUID! @id
  created_at: DateTime @createdAt
  updated_at: DateTime @updatedAt
  user: User! @relation(link: INLINE, name: "CompletionRegisteredToUser")
  course: Course! @relation(link: INLINE, name: "CompletionRegisteredToCourse")
  "Confirmed student number"
  real_student_number: String!
  "Link to completion whose register info this is"
  completion: Completion! @relation(link: INLINE, name: "CompletionRegisteredToCompletion")
  organization: Organization @relation(link:INLINE, name: "CompletionRegisteredToOrganization")
}

type Service @db(name: "service") {
  id: UUID! @id
  created_at: DateTime @createdAt
  updated_at: DateTime @updatedAt
  url: String!
  name: String!
  courses: [Course] @relation(name: "CourseToService")
}

type UserCourseProgress @db(name: "user_course_progress") {
  id: UUID! @id
  created_at: DateTime @createdAt
  updated_at: DateTime @updatedAt
  user: User! @relation(link: INLINE, name: "UserCourseProgressToUser")
  course: Course! @relation(link: INLINE, name: "UserCourseProgressToCourse")
  "Json containing all progress data for User in a course"
  progress: Json!
  user_course_service_progresses: [UserCourseServiceProgress!]! @relation(name:"UserCourseServiceProgressToUserCourseProgress")
}


type UserCourseServiceProgress @db(name: "user_course_service_progress") {
  id: UUID! @id
  created_at: DateTime @createdAt
  updated_at: DateTime @updatedAt
  user: User! @relation(link: INLINE, name: "UserCourseServiceProgressToUser")
  course: Course! @relation(link: INLINE, name: "UserCourseServiceProgressToCourse")
  service: Service! @relation(link: INLINE, name: "UserCourseServiceProgressToService")
  "User's progress in a course in a spesific course"
  progress: Json!
  user_course_progress: UserCourseProgress! @relation(link: INLINE, name: "UserCourseServiceProgressToUserCourseProgress")
  timestamp: DateTime
}

type Organization @db(name: "organization") {
  id: UUID! @id
  created_at: DateTime @createdAt
  updated_at: DateTime @updatedAt
  slug: String! @unique
  verified_at: DateTime
  verified: Boolean
  disabled: Boolean
  hidden: Boolean
  creator: User @relation(link: INLINE, name: "OrganizationToUser")
  tmc_created_at: DateTime
  tmc_updated_at: DateTime
  logo_file_name: String
  logo_content_type: String
  logo_file_size: Int
  logo_updated_at: DateTime
  phone: String
  contact_information: String
  email: String
  website: String
  pinned: Boolean
  secret_key: String! @unique
  completions_registered: [CompletionRegistered!]! @relation(name: "CompletionRegisteredToOrganization")
  organization_translations: [OrganizationTranslation!]! @relation(name: "OrganizationToOrganizationTranslation")
}

type OrganizationTranslation @db(name: "organization_translation") {
  id: UUID! @id
  created_at: DateTime @createdAt
  updated_at: DateTime @updatedAt
  language: String!
  name: String!
  disabled_reason: String
  information: String
  organization: Organization! @relation(link: INLINE, name: "OrganizationToOrganizationTranslation")
}
