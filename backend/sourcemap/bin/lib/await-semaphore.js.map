{"version":3,"file":"await-semaphore.js","sourceRoot":"","sources":["../../../bin/lib/await-semaphore.ts"],"names":[],"mappings":";;;;AAAA;IAIE,mBAAY,KAAa;QAHjB,UAAK,GAAmB,EAAE,CAAA;QAIhC,IAAI,CAAC,KAAK,GAAG,KAAK,CAAA;IACpB,CAAC;IAEO,yBAAK,GAAb;QACE,IAAI,IAAI,CAAC,KAAK,GAAG,CAAC,IAAI,IAAI,CAAC,KAAK,CAAC,MAAM,GAAG,CAAC,EAAE;YAC3C,IAAI,CAAC,KAAK,EAAE,CAAA;YACZ,IAAI,IAAI,GAAG,IAAI,CAAC,KAAK,CAAC,KAAK,EAAE,CAAA;YAC7B,IAAI,IAAI,KAAK,SAAS,EAAE;gBACtB,MAAM,0CAA0C,CAAA;aACjD;YAED,IAAI,EAAE,CAAA;SACP;IACH,CAAC;IAEM,2BAAO,GAAd;QAAA,iBAmBC;QAlBC,OAAO,IAAI,OAAO,CAAa,UAAC,GAAG,EAAE,CAAC;YACpC,IAAI,IAAI,GAAG;gBACT,IAAI,QAAQ,GAAG,KAAK,CAAA;gBACpB,GAAG,CAAC;oBACF,IAAI,CAAC,QAAQ,EAAE;wBACb,QAAQ,GAAG,IAAI,CAAA;wBACf,KAAI,CAAC,KAAK,EAAE,CAAA;wBACZ,KAAI,CAAC,KAAK,EAAE,CAAA;qBACb;gBACH,CAAC,CAAC,CAAA;YACJ,CAAC,CAAA;YACD,KAAI,CAAC,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,CAAA;YACrB,IAAI,OAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,QAAQ,EAAE;gBACrB,OAAO,CAAC,QAAQ,CAAC,KAAI,CAAC,KAAK,CAAC,IAAI,CAAC,KAAI,CAAC,CAAC,CAAA;aACxC;iBAAM;gBACL,YAAY,CAAC,KAAI,CAAC,KAAK,CAAC,IAAI,CAAC,KAAI,CAAC,CAAC,CAAA;aACpC;QACH,CAAC,CAAC,CAAA;IACJ,CAAC;IAEM,uBAAG,GAAV,UAAc,CAAmB;QAC/B,OAAO,IAAI,CAAC,OAAO,EAAE,CAAC,IAAI,CAAC,UAAC,OAAO;YACjC,OAAO,CAAC,EAAE;iBACP,IAAI,CAAC,UAAC,GAAG;gBACR,OAAO,EAAE,CAAA;gBACT,OAAO,GAAG,CAAA;YACZ,CAAC,CAAC,CACD,OAAK,CAAA,CAAC,UAAC,GAAG;gBACT,OAAO,EAAE,CAAA;gBACT,MAAM,GAAG,CAAA;YACX,CAAC,CAAC,CAAA;QACN,CAAC,CAAC,CAAA;IACJ,CAAC;IACH,gBAAC;AAAD,CAAC,AAtDD,IAsDC;AAtDY,8BAAS;AAwDtB;IAA2B,iCAAS;IAClC;eACE,kBAAM,CAAC,CAAC;IACV,CAAC;IACH,YAAC;AAAD,CAAC,AAJD,CAA2B,SAAS,GAInC;AAJY,sBAAK","sourcesContent":["export class Semaphore {\n  private tasks: (() => void)[] = []\n  count: number\n\n  constructor(count: number) {\n    this.count = count\n  }\n\n  private sched() {\n    if (this.count > 0 && this.tasks.length > 0) {\n      this.count--\n      let next = this.tasks.shift()\n      if (next === undefined) {\n        throw \"Unexpected undefined value in tasks list\"\n      }\n\n      next()\n    }\n  }\n\n  public acquire() {\n    return new Promise<() => void>((res, _) => {\n      var task = () => {\n        var released = false\n        res(() => {\n          if (!released) {\n            released = true\n            this.count++\n            this.sched()\n          }\n        })\n      }\n      this.tasks.push(task)\n      if (process?.nextTick) {\n        process.nextTick(this.sched.bind(this))\n      } else {\n        setImmediate(this.sched.bind(this))\n      }\n    })\n  }\n\n  public use<T>(f: () => Promise<T>) {\n    return this.acquire().then((release) => {\n      return f()\n        .then((res) => {\n          release()\n          return res\n        })\n        .catch((err) => {\n          release()\n          throw err\n        })\n    })\n  }\n}\n\nexport class Mutex extends Semaphore {\n  constructor() {\n    super(1)\n  }\n}\n"]}