{"version":3,"file":"updateCourseStatuses.js","sourceRoot":"","sources":["../../bin/updateCourseStatuses.ts"],"names":[],"mappings":";;;AAAA,oFAA0E;AAC1E,+BAAgC;AAChC,gEAAuC;AAEvC,IAAM,MAAM,GAAG,mBAAY,EAAE,CAAA;AAE7B,IAAM,oBAAoB,GAAG;;;;oBACX,qBAAM,MAAM,CAAC,MAAM,CAAC,QAAQ,CAAC,EAAE,CAAC,EAAA;;gBAA1C,OAAO,GAAG,SAAgC;gBAC1C,aAAa,GAAG,IAAI,0BAAa,EAAE,CAAA;gBAEzC,OAAO,CAAC,GAAG,CACT,OAAO,CAAC,GAAG,CAAC,UAAO,MAAM;;;;;gCACf,MAAM,GAAK,MAAM,OAAX,CAAW;gCAErB,SAAS,GAAG,MAAM,CAAA;gCAEhB,eAAe,GAAG,MAAM,CAAC,UAAU;oCACvC,CAAC,CAAC,gBAAQ,CAAC,OAAO,CAAC,MAAM,CAAC,UAAU,CAAC;oCACrC,CAAC,CAAC,IAAI,CAAA;gCACF,aAAa,GAAG,MAAM,CAAC,QAAQ;oCACnC,CAAC,CAAC,gBAAQ,CAAC,OAAO,CAAC,MAAM,CAAC,QAAQ,CAAC;oCACnC,CAAC,CAAC,IAAI,CAAA;gCACF,WAAW,GAAG,gBAAQ,CAAC,KAAK,EAAE,CAAA;gCACpC,IACE,SAAS,KAAK,UAAU;oCACxB,eAAe;oCACf,WAAW,IAAI,eAAe,EAC9B;oCACA,SAAS,GAAG,QAAQ,CAAA;iCACrB;gCACD,IACE,SAAS,KAAK,QAAQ;oCACtB,aAAa;oCACb,WAAW,GAAG,aAAa,EAC3B;oCACA,SAAS,GAAG,OAAO,CAAA;iCACpB;gCAED,IAAI,MAAM,KAAK,SAAS,EAAE;oCACxB,sBAAO,OAAO,CAAC,OAAO,EAAE,EAAA;iCACzB;gCAEqB,qBAAM,MAAM,CAAC,MAAM,CAAC,MAAM,CAAC;wCAC/C,KAAK,EAAE;4CACL,EAAE,EAAE,MAAM,CAAC,EAAE;yCACd;wCACD,IAAI,EAAE;4CACJ,MAAM,EAAE,SAAS;yCAClB;qCACF,CAAC,EAAA;;gCAPI,aAAa,GAAG,SAOpB;gCACF,OAAO,CAAC,GAAG,CACT,oBAAkB,MAAM,CAAC,IAAI,cAAS,MAAM,YAAO,SAAW,CAC/D,CAAA;gCACK,GAAG,GAAoB;oCAC3B,OAAO,EAAE,IAAI,CAAC,SAAS,CAAC,aAAa,CAAC;oCACtC,SAAS,EAAE,IAAI;oCACf,KAAK,EAAE,uBAAuB;iCAC/B,CAAA;gCACD,qBAAM,aAAa,CAAC,oBAAoB,CAAC,GAAG,CAAC,EAAA;;gCAA7C,SAA6C,CAAA;;;;qBAC9C,CAAC,CACH,CAAA;gBACD,qBAAM,aAAa,CAAC,UAAU,EAAE,EAAA;;gBAAhC,SAAgC,CAAA;;;;KACjC,CAAA;AAED,oBAAoB,EAAE,CAAA","sourcesContent":["import KafkaProducer, { ProducerMessage } from \"../services/kafkaProducer\"\nimport { DateTime } from \"luxon\"\nimport prismaClient from \"./lib/prisma\"\n\nconst prisma = prismaClient()\n\nconst updateCourseStatuses = async () => {\n  const courses = await prisma.course.findMany({})\n  const kafkaProducer = new KafkaProducer()\n\n  Promise.all(\n    courses.map(async (course) => {\n      const { status } = course\n\n      let newStatus = status\n\n      const courseStartDate = course.start_date\n        ? DateTime.fromISO(course.start_date)\n        : null\n      const courseEndDate = course.end_date\n        ? DateTime.fromISO(course.end_date)\n        : null\n      const currentDate = DateTime.local()\n      if (\n        newStatus === \"Upcoming\" &&\n        courseStartDate &&\n        currentDate >= courseStartDate\n      ) {\n        newStatus = \"Active\"\n      }\n      if (\n        newStatus === \"Active\" &&\n        courseEndDate &&\n        currentDate > courseEndDate\n      ) {\n        newStatus = \"Ended\"\n      }\n\n      if (status === newStatus) {\n        return Promise.resolve()\n      }\n\n      const updatedCourse = await prisma.course.update({\n        where: {\n          id: course.id,\n        },\n        data: {\n          status: newStatus,\n        },\n      })\n      console.log(\n        `Updated course ${course.name} from ${status} to ${newStatus}`,\n      )\n      const msg: ProducerMessage = {\n        message: JSON.stringify(updatedCourse),\n        partition: null,\n        topic: \"updated-course-status\",\n      }\n      await kafkaProducer.queueProducerMessage(msg)\n    }),\n  )\n  await kafkaProducer.disconnect()\n}\n\nupdateCourseStatuses()\n"]}