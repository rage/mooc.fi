{"version":3,"file":"handleMessage.js","sourceRoot":"","sources":["../../../../bin/kafkaConsumer/common/handleMessage.ts"],"names":[],"mappings":";;;;AAKA,uEAAmC;AAEnC,IAAI,aAAa,GAAG,CAAC,CAAA;AAErB,IAAM,cAAc,GAAG,wBAAM,CAAC,eAAe,CAAA;AAgBhC,QAAA,aAAa,GAAG,UAA8C,EAQ5C;QAP7B,YAAY,kBAAA,EACZ,KAAK,WAAA,EACL,MAAM,YAAA,EACN,QAAQ,cAAA,EACR,MAAM,YAAA,EACN,gBAAgB,sBAAA,EAChB,cAAc,oBAAA;;;;;;wBAGE,qBAAM,KAAK,CAAC,OAAO,EAAE,EAAA;;oBAA/B,OAAO,GAAG,SAAqB;oBACrC,MAAM,CAAC,IAAI,CAAC,qBAAqB,CAAC,CAAA;;;;oBAGhC,OAAO,GAAG,IAAI,CAAC,KAAK,aAAC,YAAY,aAAZ,YAAY,uBAAZ,YAAY,CAAE,KAAK,0CAAE,QAAQ,CAAC,MAAM,oCAAK,EAAE,CAAC,CAAA;;;;oBAEjE,MAAM,CAAC,KAAK,CAAC,iBAAiB,EAAE,GAAC,CAAC,CAAA;oBAClC,qBAAM,MAAM,CAAC,YAAY,EAAE,QAAQ,CAAC,EAAA;;oBAApC,SAAoC,CAAA;oBACpC,OAAO,EAAE,CAAA;oBACT,sBAAM;;;oBAIN,qBAAM,gBAAgB,CAAC,QAAQ,CAAC,OAAO,CAAC,EAAA;;oBAAxC,SAAwC,CAAA;;;;oBAExC,MAAM,CAAC,KAAK,CAAC,wBAAwB,GAAG,OAAK,EAAE;wBAC7C,OAAO,EAAE,IAAI,CAAC,SAAS,CAAC,OAAO,CAAC;qBACjC,CAAC,CAAA;oBACF,qBAAM,MAAM,CAAC,YAAY,EAAE,QAAQ,CAAC,EAAA;;oBAApC,SAAoC,CAAA;oBACpC,OAAO,EAAE,CAAA;oBACT,sBAAM;;;oBAIN,MAAM,CAAC,IAAI,CAAC,oBAAoB,GAAG,OAAO,CAAC,SAAS,CAAC,CAAA;oBAC/C,qBAAM,cAAc,CAAC,OAAO,EAAE,MAAM,EAAE,MAAM,CAAC,EAAA;;oBAAnD,IAAI,CAAC,CAAC,SAA6C,CAAC,EAAE;wBACpD,MAAM,CAAC,KAAK,CAAC,kCAAkC,CAAC,CAAA;qBACjD;;;;oBAED,MAAM,CAAC,KAAK,CAAC,mCAAmC,EAAE,OAAK,CAAC,CAAA;;yBAE1D,qBAAM,MAAM,CAAC,YAAY,EAAE,QAAQ,CAAC;oBACpC,iBAAiB;kBADmB;;oBAApC,SAAoC,CAAA;oBACpC,iBAAiB;oBACjB,OAAO,EAAE,CAAA;;;;;CACV,CAAA;AAED,IAAM,MAAM,GAAG,UAAO,OAAY,EAAE,QAAuB;;;;qBACrD,CAAA,aAAa,IAAI,cAAc,CAAA,EAA/B,wBAA+B;gBACjC,qBAAM,QAAQ,CAAC,aAAa,CAAC,OAAO,CAAC,EAAA;;gBAArC,SAAqC,CAAA;gBACrC,aAAa,GAAG,CAAC,CAAA;;;gBAEnB,aAAa,EAAE,CAAA;;;;KAChB,CAAA","sourcesContent":["import { PrismaClient } from \"@prisma/client\"\nimport { Mutex } from \"../../lib/await-semaphore\"\nimport { Logger } from \"winston\"\nimport { KafkaConsumer, Message as KafkaMessage } from \"node-rdkafka\"\nimport * as yup from \"yup\"\nimport config from \"../kafkaConfig\"\n\nlet commitCounter = 0\n\nconst commitInterval = config.commit_interval\n\ninterface HandleMessageConfig<Message extends { timestamp: string }> {\n  kafkaMessage: KafkaMessage\n  mutex: Mutex\n  logger: Logger\n  consumer: KafkaConsumer\n  prisma: PrismaClient\n  MessageYupSchema: yup.ObjectSchema<any>\n  saveToDatabase: (\n    message: Message,\n    prisma: PrismaClient,\n    logger: Logger,\n  ) => Promise<any>\n}\n\nexport const handleMessage = async <Message extends { timestamp: string }>({\n  kafkaMessage,\n  mutex,\n  logger,\n  consumer,\n  prisma,\n  MessageYupSchema,\n  saveToDatabase,\n}: HandleMessageConfig<Message>) => {\n  //Going to mutex\n  const release = await mutex.acquire()\n  logger.info(\"Handling a message.\")\n  let message: Message\n  try {\n    message = JSON.parse(kafkaMessage?.value?.toString(\"utf8\") ?? \"\")\n  } catch (e) {\n    logger.error(\"invalid message\", e)\n    await commit(kafkaMessage, consumer)\n    release()\n    return\n  }\n\n  try {\n    await MessageYupSchema.validate(message)\n  } catch (error) {\n    logger.error(\"JSON VALIDATE FAILED: \" + error, {\n      message: JSON.stringify(message),\n    })\n    await commit(kafkaMessage, consumer)\n    release()\n    return\n  }\n\n  try {\n    logger.info(\"Saving. Timestamp \" + message.timestamp)\n    if (!(await saveToDatabase(message, prisma, logger))) {\n      logger.error(\"Could not save event to database\")\n    }\n  } catch (error) {\n    logger.error(\"Could not save event to database:\", error)\n  }\n  await commit(kafkaMessage, consumer)\n  //Releasing mutex\n  release()\n}\n\nconst commit = async (message: any, consumer: KafkaConsumer) => {\n  if (commitCounter >= commitInterval) {\n    await consumer.commitMessage(message)\n    commitCounter = 0\n  }\n  commitCounter++\n}\n"]}